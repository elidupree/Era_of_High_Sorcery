this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- unit_types.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

local w111 = wesnoth.compare_versions(wesnoth.game_config.version, ">=", "1.11.0")

EoHS.do_special_advancement_next = function(unit)
  return EoHS.get_unit_variable(unit, "is_wizard") or ((unit.advances_to == unit.type) and EoHS.get_unit_variable(unit, "is_summon"))
end

local wizard_max_experience_table = {
   54, --wesnoth.unit_types[     "Mage"].max_experience,
  100, --wesnoth.unit_types[ "Red Mage"].max_experience,
  220, --wesnoth.unit_types["Arch Mage"].max_experience,
}
EoHS.wizard_max_experience = function(level)
  if level < 1 then return math.ceil(wizard_max_experience_table[1] / (2-level)) end
  if level > 3 then return wizard_max_experience_table[3] + (120*(level - 3)) end
  return wizard_max_experience_table[level]
end
local wizard_max_hitpoints_table = {
  wesnoth.unit_types[      "Mage"].max_hitpoints,
  wesnoth.unit_types[  "Red Mage"].max_hitpoints,
  wesnoth.unit_types[ "Arch Mage"].max_hitpoints,
  wesnoth.unit_types["Great Mage"].max_hitpoints,
}
EoHS.wizard_max_hitpoints = function(level)
  local val
      if level < 1 then val = math.ceil(wizard_max_hitpoints_table[1] / (2-level))
  elseif level > 4 then val = wizard_max_hitpoints_table[4] + (11*(level - 4))
  else val = wizard_max_hitpoints_table[level] end
  return val + 10
end
local wizard_advancement_lines = {
  {"Mage","Red Mage","Arch Mage","Great Mage"},
  {"White Mage","White Mage","Mage of Light"},
  {"Dark Adept","Dark Sorcerer","Necromancer"},
  {"Dwarvish Runesmith","Dwarvish Runesmith","Dwarvish Runemaster","Dwarvish Arcanister"},
  {"Elvish Lord","Elvish Lord","Elvish High Lord"},
  {"Saurian Augur","Saurian Soothsayer"},
  {"Mermaid Initiate","Mermaid Enchantress","Mermaid Siren"},
  {"Mermaid Priestess","Mermaid Diviner"},
}
for i,line in ipairs(wizard_advancement_lines) do
  for i,unit_type in ipairs(line) do
    line[unit_type] = true
    wizard_advancement_lines[unit_type] = line
  end
end
local same_line = function(unit_type1, unit_type2)
  if unit_type1 == unit_type2 then return true end
  local line = wizard_advancement_lines[unit_type1]
  return line and line[unit_type2] or false
end
EoHS.appropriate_wizard_unit_type = function(reference_type, level)
  local line = wizard_advancement_lines[reference_type]
  if line then
    if level < 1 then return line[1] end
    return line[level] or line[#line]
  end
  
  return nil
end
EoHS.is_building = function(unit)
  return EoHS.get_unit_variable(unit, "is_building")
end
EoHS.custom_races = {
  --EoHS_building = { name=_"Building", base_race = "mechanical" },
  EoHS_magic = { name=_"Magical force", base_race = "monster" },
  EoHS_cat = { name=_"Cat", base_race = "monster" },
}
EoHS.unit_race = function(unit)
  return EoHS.get_unit_variable(unit, "race") or unit.race
end
EoHS.set_unit_race = function(unit, race)
  if EoHS.custom_races[race] then
    EoHS.set_unit_variable(unit, "race", race)
    unit.race = EoHS.custom_races[race].base_race
  else
    EoHS.set_unit_variable(unit, "race")
    unit.race = race
  end
end

-- TODO: Rename this function to be in line with the other functions' style?
-- (e.g. the "all" is unnecessary and we could use something like "attributes" rather than "adjustments",
--   since this mostly is intended to overwrite things rather than tweaking them)
EoHS.update_all_type_adjustments = function(unit)
  local variables = EoHS.force_unit_variables(unit)
  if not variables.original_type then variables.original_type = unit.type end
  local original_type = variables.original_type
  local reference_type = original_type
  if variables.is_wizard and (reference_type == "Elvish Lady") then reference_type = EoHS.appropriate_wizard_unit_type("Elvish Lord", variables.wizard_level) end
  local type_cfg = EoHS.unit_type_with_gender_and_variation(reference_type, unit.gender, unit.variation)
  unit.level = type_cfg.level
  unit.type = original_type
  unit.advances_to = type_cfg.advances_to
  unit.alignment = type_cfg.alignment
  unit.cost = type_cfg.cost
  EoHS.set_unit_race(unit, type_cfg.race)
  variables.despair_ability = nil
  local type_in = function(list) for t in EoHS.comma_separated_values(list) do if original_type == t then return true end end; return false end
  
  local hitpoints = type_cfg.hitpoints
  local experience = type_cfg.experience
  local extra_effects_before_extra_attacks = {}
  local extra_attacks = {}
  local extra_effects = {}
  local make_effect = function(apply_to, contents, before_extra_attacks)
    contents.apply_to = apply_to
    table.insert(before_extra_attacks and extra_effects_before_extra_attacks or extra_effects, { "effect", contents })
  end
  -- We'd remove AMLA for units with special advancements, but we can't; fortunately it's overridden by the valid advances_to
  local first_attack = helper.get_child(type_cfg, "attack")
  local default_melee_names = {first_attack and first_attack.name}
  local default_melee_effects = {}
  local type_name_override = nil
  local force_zoc = nil
  
  if variables.is_crypt then
    variables.is_building = true
    force_zoc = false
    type_name_override = _"Crypt"
    variables.type_description_override = _"The crypt of a Lich. As long as this crypt exists, the lich cannot truly die."
    unit.profile = "unit_image"
    unit.advances_to = "null" -- doesn't work
    experience = 10000
    make_effect("remove_attacks", {}, true)
    make_effect("remove_ability", { { "abilities", EoHS.macros.ABILITY_SUBMERGE } }) -- would be too cruel if it was effective at all, otherwise pointless/annoying
    make_effect("movement", { set=0 })
    
    make_effect("defense", { replace = true, { "defense", { 
      flat=80, fungus=80, hills  =80, mountains =80,
      sand=80, forest=80, village=80, swamp_water=80, shallow_water=80, deep_water=80,
      cave=80, frozen=80, castle =80, unwalkable=80, }}})
    make_effect("resistance", { replace = true, { "resistance", { blade = 40, pierce = 40, impact = 50, fire = 50, arcane = 60, cold = 40 }}, })
    make_effect("new_ability", { { "abilities", EoHS.abilities.regen_lesser } })
  end
  
  if variables.is_swarm_nest then
    variables.is_building = true
    force_zoc = false
    type_name_override = _"Swarm Nest"
    variables.type_description_override = _"A nest that spawns an AI-controlled unit onto each adjacent empty hex every turn."
    unit.profile = "unit_image"
    experience = 10000
    hitpoints = 95
    make_effect("remove_attacks", {}, true)
    make_effect("movement", { set=0 })
    
    make_effect("defense", { replace = true, { "defense", { 
      flat=80, fungus=80, hills  =80, mountains =80,
      sand=80, forest=80, village=80, swamp_water=80, shallow_water=80, deep_water=80,
      cave=80, frozen=80, castle =80, unwalkable=80, }}})
    make_effect("resistance", { replace = true, { "resistance", { blade = 100, pierce = 80, impact = 100, fire = 150, arcane = 80, cold = 80 }}, })
    make_effect("new_ability", { { "abilities", EoHS.abilities.regen_lesser } })
    make_effect("image_mod", { replace = "~O(0)~BLIT(scenery/nest-full.png)" })
  end
  
  if variables.is_portal then
    variables.is_building = true
    force_zoc = false
    type_name_override = _"Portal"
    variables.type_description_override = _"A portal that allows all allied units to travel instantly to any other portal."
    EoHS.set_unit_race(unit, "mechanical")
    unit.profile = "unit_image"
    experience = 10000
    hitpoints = 60
    unit.level = 0
    make_effect("remove_attacks", {}, true)
    make_effect("movement", { set=0 })
    
    make_effect("defense", { replace = true, { "defense", { 
      flat=80, fungus=80, hills  =80, mountains =80,
      sand=80, forest=80, village=80, swamp_water=80, shallow_water=80, deep_water=80,
      cave=80, frozen=80, castle =80, unwalkable=80, }}})
    make_effect("resistance", { replace = true, { "resistance", { blade = 60, pierce = 40, impact = 60, fire = 40, arcane = 100, cold = 40 }}, })
    make_effect("new_ability", { { "abilities", EoHS.abilities.regen_lesser } })
    make_effect("image_mod", { replace = "~O(0)~BLIT(scenery/rock-cairn.png~BL(2)~CS(-255,-255,-255)"..EoHS.TC_like_CS(unit.side).."~O(5))~BLIT(scenery/rock-cairn.png)" })
  end
  
  if variables.is_circle_of_protection then
    variables.is_building = true
    type_name_override = _"Circle of Protection"
    variables.type_description_override = _"A magic circle that defends a hex from all magic."
    EoHS.set_unit_race(unit, "EoHS_magic")
    unit.profile = "unit_image"
    experience = 10000
    hitpoints = 50
    unit.level = 0
    make_effect("remove_attacks", {}, true)
    make_effect("movement", { set=0 })
    
    make_effect("defense", { replace = true, { "defense", { 
      flat=50, fungus=50, hills  =50, mountains =50,
      sand=50, forest=50, village=50, swamp_water=50, shallow_water=50, deep_water=50,
      cave=50, frozen=50, castle =50, unwalkable=50, }}})
    make_effect("resistance", { replace = true, { "resistance", { blade = 100, pierce = 100, impact = 100, fire = 100, arcane = 100, cold = 100 }}, })
    make_effect("new_ability", { { "abilities", { {"regenerate",{
      value = 12,
      id = "EoHS_circle_of_protection_regen",
      name = _"regenerates +12",
      description = _"The unit will heal itself 12 HP per turn. If it is poisoned, it will remove the poison instead of healing.",
      affect_self = true,
      poison = "cured",
    }} }} })
    make_effect("image_mod", { replace = "~O(0)" })
  end
  
  if variables.is_black_cat and (unit.type == "Rogue" or unit.type == "Assassin") then
    unit.profile = "unit_image"
    type_name_override = _"Black Cat"
    if unit.type == "Rogue" then
      unit.level = 0
      experience = 29
    else
      unit.level = 1
      experience = 50
    end
    force_zoc = (unit.level > 0)
    EoHS.set_unit_race(unit, "EoHS_cat")
    unit.cost = 9 + unit.level*6
    hitpoints = 22 + unit.level*13
    make_effect("movement", { set = 4 + unit.level })
    make_effect("remove_attacks", {}, true)
    make_effect("remove_ability", { { "abilities", EoHS.macros.ABILITY_SKIRMISHER } })
    table.insert(extra_attacks, {
      name = "claws",
      description = _"claws",
      icon = "attacks/claws-animal.png",
      type = "blade",
      range = "melee",
      damage = 4 + unit.level*3,
      number = 3,
    })
    make_effect("new_ability", { { "abilities", {
      { "teleport", {
        id = "EoHS_underfoot",
        name= _ "underfoot",
        female_name= _ "female^underfoot",
        description= _ "This unit may teleport to anywhere next to a friendly unit (except other units with this ability).",
        { "tunnel", {
          id = "EoHS_underfoot",
          { "filter", {
            ability = "EoHS_underfoot",
          } },
          { "source", {
          } },
          { "target", {
            { "not", {
              { "filter", {
              } },
            } },
            { "filter_adjacent_location", {
              { "filter", {
                { "filter_side", {
                  { "allied_with", {
                    side="$teleport_unit.side"
                  } },
                } },
                { "not", {
                  ability = "EoHS_underfoot",
                } },
              } },
            } },
          } },
        } },
      } },
    } } })
    local wolf = EoHS.collapse_image_aggregate("image_modded", EoHS.image_aggregate_except("units/monsters/wolf.png", { x1=52,y2=50,relative_to_base_image = "units/monsters/wolf.png" })).."~CS(-115,-80,-30)~SCALE(45,45)"
    local bat = "units/undead/dreadbat-se-3.png~CROP(32,18,11,13)~TC(5,magenta)"
    make_effect("image_mod", { replace = "~O(0)~BLIT("..wolf..",13,14)~BLIT("..bat..",40,29)" })
  end
  
  if variables.is_skeletal_dragon then
    hitpoints = 216
    make_effect("attack", { increase_damage = 4, increase_attacks = 2 })
    make_effect("movement", { set=8 })
    
    -- as Skeleton
    make_effect("movement_costs", { replace = true, { "movement_costs", { 
      deep_water=3,
      shallow_water=2,
      reef=2,
      swamp_water=2,
      flat=1,
      sand=2,
      forest=2,
      hills=2,
      mountains=3,
      village=1,
      castle=1,
      cave=2,
      frozen=2,
      fungus=2,
    }}})
    make_effect("defense", { replace = true, { "defense", { 
      deep_water=90,
      shallow_water=80,
      reef=70,
      swamp_water=70,
      flat=60,
      sand=70,
      forest=50,
      hills=50,
      mountains=40,
      village=40,
      castle=40,
      cave=60,
      frozen=70,
      fungus=40,
    }}})
    -- Leave the normal (better than Skeleton) resistances
    --[[make_effect("resistance", { replace = true, { "resistance", {
      blade=60,
      pierce=40,
      impact=120,
      fire=120,
      cold=40,
      arcane=150,
    }}})]]
    
    --make_effect("new_ability", { { "abilities", {{ "dummy", {name=_"",description=_""} }} } })
  end
  
  if variables.is_swarm and (original_type == "Tentacle of the Deep") then
    unit.level = 0
  end
  
  local special_ids_found = {}
  if EoHS.get_unit_variable(unit, "is_summon") then
    if (original_type == "Chocobone") then
      unit.cost = 26
      unit.advances_to = "Death Knight"
      experience = 90
      if not w111 then
        -- backport 1.11 mainline buff
        make_effect("attack", { name = "spear", increase_damage = 2 })
      end
    elseif (original_type == "Death Knight") then
      unit.cost = 48
      make_effect("movement", { set = 9 })
      make_effect("attack", { name = "battle axe", increase_damage = -2 })
      table.insert(extra_attacks, {
        name = "spear",
        description = _"spear",
        type = "pierce",
        range = "melee",
        damage = 14,
        number = 2,
        { "specials", EoHS.macros.WEAPON_SPECIAL_CHARGE },
      })
    end
    
    if (original_type ==       "Wolf") then experience = 30; unit.advances_to = "Great Wolf"; unit.cost = 15 end
    if (original_type == "Great Wolf") then experience = 65; unit.advances_to =   "Direwolf"; make_effect("attack", { increase_damage = 2 }) end
    if (original_type ==   "Direwolf") then                                                   make_effect("attack", { increase_damage = 2 }) end
    
    if (original_type == "Fire Guardian") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 6
        unit.advances_to = original_type
        experience = 31
      else
        type_name_override = _"Fire Aggressor"
        unit.level = 2
        unit.cost = 26
        experience = 100
        hitpoints = hitpoints + 22
        make_effect("attack", { name = "fire claws", increase_damage = 2, increase_attacks = 1 })
        make_effect("attack", { name = "fire breath", increase_damage = 2, increase_attacks = 1 })
        make_effect("image_mod", { add = "~CS(50,-60,-90)", })
      end
    end
    
    if (original_type == "Giant Scorpion") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 19
        unit.advances_to = original_type
        experience = 34
      else
        type_name_override = _"Plated Scorpion"
        unit.level = 2
        unit.cost = 29
        experience = 100
        hitpoints = hitpoints + 10
        make_effect("resistance", { replace = true, { "resistance", { blade = 70, pierce = 70, fire = 120, arcane = 110, cold = 100 }}, })
        make_effect("attack", { name = "pincers", increase_damage = 2 })
        make_effect("attack", { name = "sting", increase_attacks = 1 })
        make_effect("image_mod", {
          { "color_palette", {
            EoHS_giant_scorpion_palette = "394960,8796b3,435778,56657c,8c9bb2,6b7b94,6b7c98,7686a0,00274f,313f5a,273649,131a24,1a2835,39455f,2f3241,31415b,92acc7,7994af,8199bd,576276,596d88,717b9e,2e3b5b,5f6d88,b5b0ce,9b98b7,5f607f,b1add0,8384a3,8180a2,414c5e,737492,384c71,1d2c49",
          }},
          { "color_range", {
            id = "EoHS_bigger_scorpion_range",
            rgb = "921e00,ffe267,000000",
          }},
          add = "~SCALE(84,84)~RC(EoHS_giant_scorpion_palette>EoHS_bigger_scorpion_range)",
        })
      end
    end
    
    if (original_type == "Gryphon") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 28
        unit.advances_to = original_type
        experience = 74
      else
        type_name_override = _"Dire Gryphon"
        unit.level = 3
        unit.cost = 48
        experience = 150
        hitpoints = hitpoints + 18
        make_effect("attack", { name = "claws", increase_damage = 4 })
        make_effect("movement", { increase = 1 })
        make_effect("image_mod", { add = "~CS(0,-20,-60)" })
      end
    end
    
    if (original_type == "Water Serpent") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 24
        unit.advances_to = original_type
        experience = 68
      else
        type_name_override = _"Slipstream Serpent"
        unit.level = 3
        unit.cost = 42
        experience = 150
        hitpoints = hitpoints + 12
        make_effect("attack", { name = "fangs", increase_attacks = 1, increase_damage = 1 })
        make_effect("movement", { increase = 1 })
        make_effect("image_mod", { add = "~CS(-60,-60,0)" })
      end
    end
    
    if (original_type == "Sea Serpent") then
      if variables.advanced_as_summon ~= original_type then
        unit.cost = 38
        unit.level = 2
        hitpoints = hitpoints - 9
        unit.advances_to = original_type
        experience = 88
      else
        type_name_override = _"Sea Behemoth"
        unit.cost = 58
        hitpoints = hitpoints + 9
        make_effect("attack", { name = "fangs", increase_damage = 7 })
        make_effect("movement", { increase = 2 })
        make_effect("image_mod", { add = w111 and "~CS(-30,-70,-90)" or "~CS(-60,-60,0)" })
        local name = _"open water only"
        local description = _"This attack can be used in deep water, shallow water, and coastal reefs, but not in river ford, swamp, or land terrains."
        table.insert(extra_attacks, {
          name = "gigantic splash",
          description = _"gigantic splash",
          icon = "attacks/waterspray.png",
          type = "impact",
          range = "ranged",
          damage = 8,
          number = 3,
          {"specials",{
            EoHS.attack_disabling_special({
              name = name,
              description = description,
              name_inactive = name,
              description_inactive = description,
              {"filter_self",{
                {"not",{
                  {"filter_location",{
                    terrain="Ww*,Wo*",
                    {"not",{ terrain="Wwf" }}
                  }}
                }}
              }}
            })
          }}
        })
      end
    end
    
    if type_in("Ghost,Shadow,Nightgaunt,Wraith,Spectre") then
      unit.cost = type_cfg.cost - 4
    end
    if type_in("Wose,Elder Wose,Ancient Wose") then
      unit.cost = type_cfg.cost - 2
    end
    if type_in("Drake Fighter,Drake Warrior,Drake Blademaster") then
      unit.cost = type_cfg.cost + 3
      if original_type == "Drake Fighter" then
        type_name_override = _"Arctic Drake"
      elseif original_type == "Drake Warrior" then
        type_name_override = _"Arctic Warrior"
      elseif original_type == "Drake Blademaster" then
        type_name_override = _"Arctic Blademaster"
      end
      make_effect("image_mod", {
        { "color_palette", {
          EoHS_drake_fighter_palette = "86ac53,fde9f1,fde6ef,fadb85,f7df8e,f6db84,dfc799,c7d95e,c3d355,c1d553,c19057,a2c157,9dba50,99b94e,7ca448,679345,5e8d44,57624d,573d2d,53844a,4c5742,4a5640,487a3f,3c513e,324634,2d4331,242e12,1c250d,151f06,100506",
        }},
        { "color_range", {
          id = "EoHS_blue_drake_range",
          rgb = "8888ff,ffffff,000000",
        }},
        add = "~RC(EoHS_drake_fighter_palette>EoHS_blue_drake_range)",
      })
      make_effect("resistance", { replace = true, { "resistance", { cold = 80, arcane = 90, }}, })
      -- I didn't originally intend to change its snow movement/defense, but the "arctic" theme requires me to (and I have nothing against it)
      make_effect("movement_costs", { replace = true, { "movement_costs", { frozen = 1, }}, })
      make_effect("defense",        { replace = true, { "defense",        { frozen = 60, }}, })
    end
    
    if original_type == "Fire Dragon" then
      type_name_override = _"Dragon"
      make_effect("remove_attacks", { range="ranged" }, true)
      make_effect("remove_ability", { { "abilities", EoHS.macros.ABILITY_LEADERSHIP_LEVEL_1 } })
      make_effect("attack", {
        name = "bite",
        { "set_specials", {
          mode = "append",
          { "dummy", {
            id = "EoHS_devour",
            name = _"devour",
            description = _"Whenever this unit kills another unit with this attack, this unit is healed by half the killed unit's max hitpoints, rounded down."
          }},
        }},
      })
      
      local dragon = EoHS.get_fake_subtag(variables, "dragon")
      hitpoints = dragon.hitpoints or 1 -- to satisfy the prototype
      unit.alignment = dragon.alignment
      make_effect("movement", { set = dragon.moves })
      
      local resistances = function(r)
        make_effect("resistance", { replace = true, { "resistance", r }, })
      end
      local defenses = function(r)
        make_effect("defense", { replace = true, { "defense", r }, })
      end
      local movement_costs = function(r)
        make_effect("movement_costs", { replace = true, { "movement_costs", r }, })
      end
      
      local most_terrains = {
        deep_water=1,
        shallow_water=1,
        reef=1,
        swamp_water=1,
        flat=1,
        sand=1,
        forest=1,
        hills=1,
        mountains=1,
        village=1,
        castle=1,
        frozen=1,
        unwalkable=1,
      }
      local d,m = {},{}
      if dragon.movetype == "fly" then
        for k in pairs(most_terrains) do d[k] = 50; m[k]=1 end
      elseif dragon.movetype == "walk" then
        -- drakefoot
        d = {
          unwalkable=100,
          deep_water=100,
          shallow_water=80,
          reef=70,
          swamp_water=80,
          flat=70,
          sand=60,
          forest=60,
          hills=60,
          mountains=60,
          village=60,
          castle=60,
          cave=70,
          frozen=80,
          fungus=60,
        }
        m = {
          unwalkable=99,
          deep_water=99,
          shallow_water=3,
          reef=2,
          swamp_water=3,
          flat=1,
          sand=1,
          forest=2,
          hills=1,
          mountains=1,
          village=1,
          castle=1,
          cave=2,
          frozen=3,
          fungus=2,
        }
      end
      
      dragon.breath_names = nil
      local make_breath = function(name, description, dam_type, specials)
        dragon.breath_names = (dragon.breath_names and dragon.breath_names.."," or "")..name
        if dragon.breath_cth == "marksman" then table.insert(specials, 1, EoHS.macros.WEAPON_SPECIAL_MARKSMAN[1]) end
        if dragon.breath_cth == "magical" then table.insert(specials, 1, EoHS.macros.WEAPON_SPECIAL_MAGICAL[1]) end
        table.insert(specials, { "dummy", {
          id = "EoHS_dragon_breath_info",
          name = _"area option",
          description = EoHS.substitute(_"The dragon may use this attack, at half damage, to strike every unit in a cone $1| hexes long and $2| degrees wide. This action costs $3| mana.", {dragon.breath_length, dragon.breath_spread*2, dragon.breath_mana})
        }})
        table.insert(extra_attacks, {
          name = name,
          description = description,
          icon = "attacks/fire-breath-drake.png",
          type = dam_type,
          range = "ranged",
          damage = dragon.breath_damage,
          number = dragon.breath_swings,
          {"specials",specials}
        })
      end
      local original_palette = "fff9d5,987b8c,aecacc,ffe39f,3d5a4b,ab718d,ff8b19,d26a2c,f6e795,ffc946,ffa32c,d9524f,b41056,b83d00,872819,c64e32,c06d01,640f46,631205,724149,430027"
      local palette_id = ""
      local rgb_funcs = {}
      local rgbonus = function(c,bonus)
        if (c==0) or (c==255) or (bonus==0) or (bonus==nil) then return c end
        return math.floor(0.5+((math.atan(math.tan(((c/255)-0.5)*math.pi)+(bonus*math.pi/255))/math.pi)+0.5)*255)
      end
      local rgb_map = function(rgb,func)
        rgb.r = func(rgb.r)
        rgb.g = func(rgb.g)
        rgb.b = func(rgb.b)
      end
      local rgbonize = function(rgb,r,g,b)
        rgb.r = rgbonus(rgb.r,r)
        rgb.g = rgbonus(rgb.g,g)
        rgb.b = rgbonus(rgb.b,b)
        EoHS.assert(rgb.r>=0)
        EoHS.assert(rgb.r<=255)
        EoHS.assert(rgb.g>=0)
        EoHS.assert(rgb.g<=255)
        EoHS.assert(rgb.b>=0)
        EoHS.assert(rgb.b<=255)
      end
      local make_mod = function(id, rgb_func)
        table.insert(rgb_funcs, rgb_func)
        palette_id = palette_id..id
      end
      if dragon.type == "fire" then
        make_breath("fire breath", _"fire breath", "fire", {})
      elseif dragon.type == "acid" then
        make_mod("acid", function(c) c.r,c.g,c.b=c.g,c.r,c.b end)
        make_breath("acid breath", _"acid breath", "fire", {EoHS.macros.WEAPON_SPECIAL_POISON[1]})
        resistances({ fire = 60, cold = 100 })
      elseif dragon.type == "lightning" then
        make_mod("lightning", function(c) c.r,c.g,c.b=(3*c.r+c.g)/4,(2*c.r+2*c.g)/4,c.b/2 end)
        make_breath("lightning breath", _"lightning breath", "lightning", {EoHS.macros.WEAPON_SPECIAL_SLOW[1]})
        resistances({ fire = 100, cold = 100, lightning = 0 })
      elseif dragon.type == "ice" then
        make_mod("ice", function(c)
          c.r,c.g,c.b=c.b,c.g,c.r
          rgbonize(c,100,100,100)
        end)
        make_breath("cold breath", _"cold breath", "cold", {})
        make_breath("ice breath", _"ice breath", "blade", {})
        resistances({ blade = 90, pierce = 80, impact = 110, fire = 150, cold = 0 })
        m.frozen = 1
        d.frozen = math.min(60, d.frozen or 100)
      elseif dragon.type == "water" then
        make_mod("water", function(c)
          c.r,c.g,c.b=c.b,c.g,c.r
          rgbonize(c,-50,0,0)
        end)
        make_breath("water breath", _"water breath", "impact", {})
        resistances({ blade = 110, pierce = 110, impact = 60, fire = 30, cold = 100 })
        m.shallow_water = 1
        m.swamp_water   = math.min( 2, m.swamp_water   or  99)
        m.deep_water    = 1
        m.reef          = 1
        d.shallow_water = math.min(60, d.shallow_water or 100)
        d.swamp_water   = math.min(60, d.swamp_water   or 100)
        d.deep_water    = math.min(60, d.deep_water    or 100)
        d.reef          = math.min(60, d.reef          or 100)
      elseif dragon.type == "spirit" then
        make_mod("spirit", function(c)
          local avg = (c.g+c.b+c.r)/3
          local fix=function(q) return (q>avg) and math.max(avg,q-30) or math.min(avg,q+30) end
          c.r,c.g,c.b=fix(c.g),fix(c.b),fix(c.r)
          rgbonize(c,avg-100,avg-100,avg-100)
        end)
        make_breath("spirit breath", _"spirit breath", "arcane", {EoHS.macros.WEAPON_SPECIAL_PLAGUE[1]})
        resistances({ blade = 110, pierce = 110, impact = 110, fire = 60, cold = 60, arcane = 0 })
      end
      defenses(d); movement_costs(m)
      
      -- make breath_cs before abilities (abilities don't affect breath type)
      local cs_rgb = {r=210,g=106,b=44}
      for i,f in ipairs(rgb_funcs) do f(cs_rgb) end
      dragon.breath_cs = "~CS("..(cs_rgb.r-128)..","..(cs_rgb.g-128)..","..(cs_rgb.b-128)..")"
      
      if dragon.ability == "leadership" then
        make_effect("new_ability", { { "abilities", EoHS.abilities.leadership(unit.level) }})
      elseif dragon.ability == "despair" then
        make_mod("despair", function(c) rgbonize(c,-50,-100,-50) end)
        make_effect("new_ability", { { "abilities", EoHS.abilities.despair } })
        variables.despair_ability = true
      elseif dragon.ability == "protection" then
        make_mod("protection", function(c)
          local avg = (c.g+c.b+c.r)/3
          if avg < 100 then
            if (dragon.type == "fire") or (dragon.type == "acid") then c.r,c.g,c.b=c.b,c.r,c.g else c.r,c.g,c.b=c.g,c.b,c.r end
          end
          --local w = 100-math.min(100,avg)
          --rgbonize(c,-w,w,0)
        end)
        make_effect("new_ability", { { "abilities", EoHS.abilities.protection } })
      elseif dragon.ability == "light_control" then
        make_effect("new_ability", { { "abilities", EoHS.abilities.light_control } })
        variables.light_control_ability = true
        if dragon.alignment == "lawful" then
          make_mod("illuminates", function(c)
            rgb_map(c, function(q) return 255-math.floor((255-q)*0.9) end)
            rgbonize(c,100,80,60)
          end)
          --make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_ILLUMINATES } })
        elseif dragon.alignment == "chaotic" then
          make_mod("deluminates", function(c)
            rgb_map(c, function(q) return math.floor(q*0.9) end)
            rgbonize(c,-100,-80,-60)
          end)
          --make_effect("new_ability", { { "abilities", EoHS.abilities.deluminates } })
        else
          make_mod("twilight", function(c)
            rgb_map(c, function(q) return math.floor(13.25+q*0.9) end)
            rgbonize(c,100-c.r,100-c.g,100-c.b)
          end)
          --make_effect("new_ability", { { "abilities", EoHS.abilities.twilight } })
        end
      end
      
      palette_id = "EoHS_dragon_"..palette_id.."_palette"
      make_effect("image_mod", {
        { "color_palette", {
          EoHS_dragon_palette = original_palette,
          [palette_id] = string.gsub(original_palette, "(..)(..)(..)(,?)", function(rs,gs,bs,comma)
            local rgb={}
            rgb.r,rgb.g,rgb.b = tonumber(rs,16),tonumber(gs,16),tonumber(bs,16)
            for i,f in ipairs(rgb_funcs) do f(rgb) end
            return string.format("%.2x%.2x%.2x",rgb.r,rgb.g,rgb.b)..comma
          end)
        }},
        add = "~PAL(EoHS_dragon_palette>"..palette_id..")",
      })
    end
  end
  
  if EoHS.get_unit_variable(unit, "is_wizard") then
    local is_a_normal_wizard_type = true
    local skills = EoHS.get_unit_skillset(unit)
    
    unit.level = EoHS.get_unit_variable(unit, "wizard_level") or unit.level
    local special_wizard_advances_to = EoHS.appropriate_wizard_unit_type(original_type, unit.level + 1)
    if special_wizard_advances_to then
      unit.advances_to = special_wizard_advances_to
    elseif (not unit.advances_to) or (unit.advances_to == "null") then
      unit.advances_to = original_type
    end
    unit.cost = 15 + unit.level*math.min(5,unit.level)*8
    unit.description = EoHS.rules
    experience = EoHS.wizard_max_experience(unit.level)
    
    --[[if (original_type == "Mage") then
      make_effect("remove_attacks", { name="missile" })
    end
    if type_in("Red Mage,Arch Mage,Great Mage") then
      make_effect("remove_attacks", { name="fireball" })
    end
    if (original_type == "Lich") then
      make_effect("remove_attacks", { name="chill tempest" })
      make_effect("remove_attacks", { name="shadow wave" })
    end]]
    if not EoHS.get_unit_variable(unit, "spiritform") then make_effect("remove_attacks", { range="ranged" }, true) end
    if original_type == "Elvish Lady" then
      unit.advances_to = original_type
      for attack in helper.child_range(type_cfg, "attack") do
        if attack.range == "melee" then
          table.insert(extra_attacks, attack)
        end
      end
      if unit.level >= 3 then
        type_name_override = _"Elvish High Lady"
      end
    end
    
    local make_attack = function(skill_name, upgrade_array, bonus, attack)
      local skill = EoHS.skillset_realm_rank(skills, skill_name)
      if skill > 0 then
        local upgrade_total = math.max(0, math.min(skill, unit.level)) + 2
        if skills.focused_study then upgrade_total = upgrade_total - 1 end
        local upgrade_array_index = math.min(#upgrade_array, upgrade_total)
        local excess = math.max(0, upgrade_total - upgrade_array_index)
        
        attack.range = "ranged"
        attack.damage = upgrade_array[upgrade_array_index][1] + math.floor(excess * bonus)
        if skills.focused_study then attack.damage = math.floor((attack.damage*8+5)/10) end
        attack.number = upgrade_array[upgrade_array_index][2]
        table.insert(attack, { "specials", EoHS.macros.WEAPON_SPECIAL_MAGICAL })
        table.insert(extra_attacks, attack)
      end
    end
    make_attack("evocation",
      {{ 6,1},{ 6,2},{ 7,3},{ 8,4}}, 4,
      {
        name = "EoHS_evocation_skill_ranged_attack",
        description = wesnoth.textdomain("wesnoth-units")("fireball"),
        icon = "attacks/fireball.png",
        type = "fire",
      }
    )
    make_attack("nature_magic",
      {{ 3,2},{ 4,3},{ 5,4},{ 7,4},{8,5}}, 2,
      {
        name = "EoHS_nature_magic_skill_ranged_attack",
        description = wesnoth.textdomain("wesnoth-units")("faerie fire"),
        icon = "attacks/faerie-fire.png",
        type = "arcane",
      }
    )
    make_attack("necromancy",
      {{ 6,1},{ 6,2},{10,2},{10,3}}, 4,
      {
        name = "EoHS_necromancy_skill_ranged_attack",
        description = wesnoth.textdomain("wesnoth-units")("chill wave"),
        icon = "attacks/iceball.png",
        type = "cold",
      }
    )
    
    hitpoints = EoHS.wizard_max_hitpoints(unit.level)
    if same_line(reference_type, "Red Mage") then
      make_effect("resistance", { replace=true, { "resistance", { fire = 100, arcane = 100, }} })
      table.insert(default_melee_effects, {
        increase_attacks = 1,
        increase_damage  = -1 + math.max(unit.level-4, 0),
      })
    elseif same_line(reference_type, "Elvish Lord") then
      unit.cost = unit.cost + 3
      hitpoints = math.floor((hitpoints*9+5)/10)
      if unit.level < 2 then table.insert(default_melee_effects, { increase_damage = 2*unit.level - 5, }) end
      if unit.level > 3 then table.insert(default_melee_effects, { increase_damage = unit.level - 3, }) end
    elseif same_line(reference_type, "Dwarvish Runesmith") then
      unit.cost = unit.cost + 4
      hitpoints = math.floor((hitpoints*21+10)/20)
      if unit.level < 2 then
        make_effect("resistance", { replace=true, { "resistance", { blade=80-10*unit.level, pierce=80, impact=80 }} })
        table.insert(default_melee_effects, { increase_damage = 3*unit.level - 8, })
      end
      if unit.level > 4 then 
        table.insert(default_melee_effects, { increase_damage = unit.level - 4, })
      end
    elseif same_line(reference_type, "Troll Shaman") then
      unit.cost = unit.cost + 7
      hitpoints = math.floor((hitpoints*23+10)/20)
      table.insert(default_melee_effects, { increase_damage = 2*unit.level - 2, })
    elseif same_line(reference_type, "Silver Mage") then
      type_name_override = _"Rogue Mage"
      unit.alignment = "chaotic"
      unit.cost = unit.cost + 2
      hitpoints = math.floor((hitpoints*19+10)/20)
      table.insert(default_melee_effects, {
        increase_attacks = (unit.level > 1) and 1 or 0,
        increase_damage  = unit.level - 3,
      })
      make_effect("remove_ability", { { "abilities", EoHS.macros.ABILITY_TELEPORT } })
      if unit.level > 1 then make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_SKIRMISHER } }) end
      -- elusivefoot
      make_effect("movement_costs", { replace = true, { "movement_costs", { 
        shallow_water=2,
        reef=2,
        swamp_water=2,
        flat=1,
        sand=2,
        forest=2,
        hills=2,
        mountains=3,
        village=1,
        castle=1,
        cave=2,
        frozen=2,
        fungus=2,
      }}})
      make_effect("defense", { replace = true, { "defense", { 
        shallow_water=60,
        reef=50,
        swamp_water=60,
        flat=40,
        sand=60,
        forest=30,
        hills=30,
        mountains=30,
        village=30,
        castle=30,
        cave=50,
        frozen=60,
        fungus=30,
      }}})
      make_effect("resistance", { replace = true, { "resistance", {
        blade=130,
        pierce=120,
        impact=120,
        fire=100,
        cold=100,
        arcane=100,
      }}})
    elseif same_line(reference_type, "Mermaid Enchantress") then
      table.insert(default_melee_effects, {
        increase_attacks = 1,
        increase_damage  = -1 + math.max(2*(unit.level-3), 0),
      })
    elseif same_line(reference_type, "Dark Adept") then
      hitpoints = math.floor((hitpoints*21+10)/20)
      make_effect("resistance", { replace=true, { "resistance", { arcane = 100, }} })
      unit.cost = unit.cost - 2
      table.insert(default_melee_effects, { increase_damage  = unit.level-3, })
    elseif same_line(reference_type, "Saurian Augur") then
      unit.cost = unit.cost - 1
      hitpoints = math.floor((hitpoints*8+5)/10)
      if unit.level > 1 then
        table.insert(default_melee_effects, {
          increase_attacks = 1,
          increase_damage  = unit.level-2,
        })
      end
    elseif same_line(reference_type, "Mermaid Priestess") or same_line(reference_type, "White Mage") then
      unit.cost = unit.cost + 3
      make_effect("resistance", { replace=true, { "resistance", { arcane = 100, }} })
      hitpoints = math.floor((hitpoints*9+5)/10)
      if unit.level < 2 then
        make_effect("remove_ability", { { "abilities", EoHS.macros.ABILITY_CURES } })
        make_effect("new_ability"   , { { "abilities", EoHS.macros.ABILITY_HEALS } })
                             table.insert(default_melee_effects, { increase_damage = unit.level - 2, }) end
      if unit.level > 3 then table.insert(default_melee_effects, { increase_damage = unit.level - 3, }) end
    elseif same_line(reference_type, "Lich") then
      unit.max_attacks = type_cfg.attacks + 1
      -- TODO: should liches retain their variant HP total?
      unit.cost = unit.cost + 12
      -- Invisibility undercuts the drama of a wizard, and this usually-irrelevant ability clutters the ability list.
      make_effect("remove_ability", {
        { "abilities", EoHS.macros.ABILITY_SUBMERGE },
      })
      table.insert(default_melee_effects, {
        increase_damage = unit.level - 3,
      })
      --[[do
        local upgrade_array = {{1,1},{4,1},{4,2}}
        local bonus = 3
        local upgrade_total = math.min(0, unit.level - 3)
        local upgrade_array_index = math.min(#upgrade_array, upgrade_total)
        local excess = math.max(0, upgrade_total - upgrade_array_index)
        
        if unit.level > 3 then
          make_effect("attack", {
            name = "chill tempest",
            increase_damage = upgrade_array[upgrade_array_index][1] + math.floor(excess * bonus),
            increase_attacks = upgrade_array[upgrade_array_index][2],
          })
          make_effect("attack", {
            name = "shadow wave",
            increase_damage = math.floor((upgrade_array[upgrade_array_index][1] + excess * bonus) * 0.75),
            increase_attacks = upgrade_array[upgrade_array_index][2],
          })
        end
      end]]
    else
      is_a_normal_wizard_type = false
      hitpoints = type_cfg.hitpoints
      table.insert(default_melee_effects, {
        increase_damage = unit.level - type_cfg.level,
      })
    end
    
    if is_a_normal_wizard_type and (original_type ~= "Lich") then
      make_effect("resistance", { replace=false, { "resistance", {
        fire   = math.min(0, 10 - math.min(EoHS.skillset_realm_rank(skills, "evocation"   ), unit.level, 4) * 10),
        cold   = math.min(0, 10 - math.min(EoHS.skillset_realm_rank(skills, "necromancy"  ), unit.level, 4) * 10),
        arcane = math.min(0, 10 - math.min(EoHS.skillset_realm_rank(skills, "nature_magic"), unit.level, 4) * 10),
      }} })
      
      if not variables.is_apprentice then
        unit.alignment = "neutral"
        if skills.khalifate then unit.alignment = "liminal"
        else
          if skills.military_commander and not skills.petty_necromancer  then unit.alignment = "lawful"  end
          if skills.petty_necromancer  and not skills.military_commander then unit.alignment = "chaotic" end
        end
      end
    end
    
    --[[if skills.mentor then
      make_effect("resistance", { replace=false, { "resistance", {
        arcane = -40,
        fire   = -40,
        cold   = -40,
      }} })
    end]]
    if skills.dwarvish_alliance then
      make_effect("resistance", { replace=false, { "resistance", {
        blade  = -20,
        impact = -20,
        pierce = -20,
      }} })
    end
    if skills.traveler then
      make_effect("movement", { increase=1 })
      make_effect("defense", { replace=false, { "defense", {
        deep_water = -10,
        shallow_water = -10,
        reef = -10,
        swamp_water = -20,
        forest = skills.elvish_alliance and 0 or -10,
        sand = skills.khalifate and 0 or -10,
        frozen = -20,
      }} })
      make_effect("movement_costs", { replace=false, { "movement_costs", {
        shallow_water = -1,
        swamp_water = -1,
        sand = -1,
        hills = -1,
        mountains = -1,
        cave = -1,
        frozen = -2,
      }} })
    end
    if skills.military_commander then
      make_effect("new_ability", { { "abilities", EoHS.abilities.leadership(unit.level) }})
    end
    if skills.rascally_friends then
      make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_SKIRMISHER } })
    end
    if skills.khalifate then
      make_effect("defense", { replace=false, { "defense", { sand = -20, }} })
      make_effect("movement_costs", { replace=false, { "movement_costs", { sand = -1, }} })
    end
    if skills.elvish_alliance then
      make_effect("new_ability", { { "abilities", (unit.level>2) and EoHS.macros.ABILITY_CURES or EoHS.macros.ABILITY_HEALS } })
      make_effect("defense", { replace=false, { "defense", { forest = -20, }} })
      make_effect("movement_costs", { replace=false, { "movement_costs", { forest = -1, }} })
    end
    if skills.orcish_mercenaries then 
      table.insert(default_melee_effects, { increase_damage = 2, })
    end
    if skills.petty_necromancer and (original_type ~= "Lich") then -- I feel like Liches shouldn't default to having plague, since they don't normally
      -- hack - don't duplicate plague... TODO a better way to do this
      special_ids_found.plague = true
      table.insert(default_melee_effects, {
        set_description = (default_melee_names[1] == "staff") and wesnoth.textdomain("wesnoth-units")("plague staff") or nil,
        set_icon = "attacks/staff-plague.png", -- Won't work until 1.11
        { "set_specials", {
          mode = "append",
          EoHS.macros.WEAPON_SPECIAL_PLAGUE[1],
        }},
      })
    end
    
    if (unit.alignment == "liminal") and not (type_cfg.alignment == "liminal") then
      make_effect("attack", {
        increase_damage = "20%",
      })
    end
    
    unit.profile = "unit_image"
    if EoHS.get_variable("settings_inited") and EoHS.get_wizard_setting(unit, "can_recruit") then
      local current_recruits = {}
      for recruit in EoHS.comma_separated_values(unit.extra_recruit) do
        current_recruits[recruit] = true
      end
      local needed_recruits = {}
      local need = function(list)
        for recruit in EoHS.comma_separated_values(list) do
          table.insert(needed_recruits, recruit)
        end
      end
      for i,alliance in ipairs(EoHS.skills.alliances) do
        if skills[alliance.id] then need(alliance.recruit) end
      end
      if skills.dwarvish_alliance and skills.summon_gryphon then need("Gryphon Rider") end
      --[[for i,recruit in ipairs(needed_recruits) do
        if not current_recruits[recruit] then
          if unit.extra_recruit == "" then
            unit.extra_recruit = recruit
          else
            unit.extra_recruit = unit.extra_recruit..","..recruit
          end
        end
      end]]
      -- Since we now have recruit removal (by becoming a lich), give up on doing the above thing to be compatible with scenario extra_recruit
      unit.extra_recruit = table.concat(needed_recruits, ",")
    end
  end
    
  local literal_variables = EoHS.get_subtag(unit, "variables")
  local intimidate = false
  local harms_strength = 0
  local mana_income -- Aggregating the mana income bonus here is a little odd, but since we're doing all the other Soul Bind things here...
  local images
  local num_souls
  local next_extra_attack_id = 2
  -- hack - don't duplicate drains... TODO a better way to do this
  if original_type == "Lich" then special_ids_found.drains = true end
  for soul in helper.child_range(literal_variables, "EoHS_bound_soul") do
    num_souls = (num_souls or 0) + 1
    images = (images or "").."BeginSoulImage"..soul.image.."EndSoulImage"
    hitpoints = hitpoints + soul.max_hitpoints
    if soul.intimidate then intimidate = true end
    harms_strength = math.max(harms_strength, soul.harms_strength)
    if soul.mana_income then mana_income = (mana_income or 0) + soul.mana_income end
    for i,subtag in ipairs(soul) do
      if subtag[1] == "abilities" then
        make_effect("new_ability", { subtag })
      end
      if subtag[1] == "stacking_specials" then
        local set_specials_contents = EoHS.deep_copy(subtag[2])
        EoHS.remove_subtags(set_specials_contents, "*", function(s)
          local has_already = special_ids_found[s.id]
          special_ids_found[s.id] = true
          return has_already
        end)
        set_specials_contents.mode = "append"
        table.insert(default_melee_effects, {
          { "set_specials", set_specials_contents },
        })
      end
      if subtag[1] == "non_stacking_specials" then
        for i,special in ipairs(subtag[2]) do
          if not special_ids_found[special[2].id] then
            special_ids_found[special[2].id] = true
            if special[2].id == "drains" then
              -- It's always good, so put it on the default attack
              make_effect("attack", { name=default_melee_names[1], { "set_specials", { mode = "append", EoHS.macros.WEAPON_SPECIAL_DRAIN[1] } } })
            else
              for attack in helper.child_range(type_cfg, "attack") do -- TODO compatibility with extra attacks?
                if attack.range == "melee" then
                  local new_attack = EoHS.deep_copy(attack)
                  new_attack.name = attack.name.."_"..next_extra_attack_id
                  table.insert(EoHS.force_subtag(new_attack, "specials"), special)
                  table.insert(extra_attacks, new_attack)
                  make_effect("attack", { name=new_attack.name, remove_specials="drains" })
                  table.insert(default_melee_names, new_attack.name)
                end
              end
            end
          end
        end
      end
    end
  end
  if intimidate then
    make_effect("new_ability", { { "abilities", EoHS.abilities.intimidate(unit.level) }})
  end
  if harms_strength > 0 then
    make_effect("new_ability", { { "abilities", { {"dummy",{
      name=EoHS.substitute(_"harms -$1|", {harms_strength}),
      description=EoHS.substitute(_"At the end of this unit's turn, each adjacent enemy loses $1| HP. This can't reduce a unit's HP below 1.", {harms_strength}),
    }} }}})
    EoHS.set_unit_variable(unit, "harms_strength", harms_strength)
  else
    EoHS.set_unit_variable(unit, "harms_strength", nil)
  end
  EoHS.set_unit_variable(unit, "soul_bind_mana_income", mana_income)
  EoHS.set_unit_variable(unit, "soul_bind_images", images)
  EoHS.set_unit_variable(unit, "souls_bound", num_souls)

  
  local original_type_cfg = type_cfg
  type_cfg = nil -- To make sure we don't use it after this, where it could be a bug (look at the original form explicitly if you don't want the current form)
 
  -- TODO: make sure stacking all the transformations turns out OK
  
  if variables.spiritform then
    -- Overwrite most stuff, but not hitpoints
    extra_attacks = {}
    extra_effects = {}
    extra_effects_before_extra_attacks = {}
    default_melee_effects = {}
    make_effect("movement", { increase=2 })
    if unit.level < 2 then unit.type = "Ghost"
    else
      if variables.spiritform_kind == "wraith" then
        unit.type = (unit.level < 3) and "Wraith" or "Spectre"
      else
        unit.type = (unit.level < 3) and "Shadow" or "Nightgaunt"
      end
    end
    local spirit_cfg = EoHS.get_unit_type(unit.type)
    
    -- TODO: aggregate the code for these and use that for all the type-changing effects
    unit.alignment = spirit_cfg.alignment
    EoHS.set_unit_race(unit, spirit_cfg.race)
    default_melee_names = {helper.get_child(spirit_cfg, "attack").name}
    type_name_override = EoHS.substitute(_"$1| ($2|)", {spirit_cfg.name, type_name_override or original_type_cfg.name})
  end
  
  -- TODO: Can we distribute some of these into their own files?
  if variables.touch_enchantment == "mud_touch" then
    table.insert(default_melee_effects, { { "set_specials", { mode = "append", EoHS.mud_touch_special }}})
  end
  if variables.touch_enchantment == "dispelling_touch" then
    table.insert(default_melee_effects, { { "set_specials", { mode = "append", EoHS.dispelling_touch_special }}})
  end
  if variables.touch_enchantment == "reanimating_touch" then
    table.insert(default_melee_effects, { { "set_specials", { mode = "append", EoHS.reanimating_touch_special }}})
  end
  
  for i,effect in ipairs(default_melee_effects) do
    effect.name = table.concat(default_melee_names, ",")
    make_effect("attack", effect)
  end
  
  if variables.ogre_fury then
    extra_attacks = {}
    extra_effects = {}
    extra_effects_before_extra_attacks = {}
    default_melee_effects = {}
    unit.type = (unit.level>0) and "Ogre" or "Young Ogre"
    hitpoints = EoHS.get_unit_type(unit.type).hitpoints
    if unit.level > 1 then
      hitpoints = hitpoints + 26*(unit.level-1)
      make_effect("attack", { name = "cleaver", increase_damage = 4*(unit.level-1) })
    end
    if unit.level == 0 then
      -- Being able to make Ogres from 6g Ruffians would feel unreasonable.
      -- But making Young Ogres with normal stats would be very disappointing and a waste of mana/gold.
      -- So we compromise.
      hitpoints = hitpoints + 5
      make_effect("attack", { name = "cleaver", increase_damage = 3 })
    end
    local new_type_cfg = EoHS.unit_type_considering_variations(unit)
    unit.alignment = new_type_cfg.alignment
    EoHS.set_unit_race(unit, new_type_cfg.race)
    type_name_override = EoHS.substitute(_"$1| ($2|)", {new_type_cfg.name, type_name_override or original_type_cfg.name})
  end
  
  if variables.mud_touched then
    local movement = EoHS.get_unit_type(unit.type).movement
    for i,effect_pair in ipairs(extra_effects) do
      local effect = effect_pair[2]
      if effect.apply_to == "movement" then
        if effect.set then movement = effect.set end
        if effect.increase then movement = movement + effect.increase end
      end
    end
    local new_name_override
    if unit.level < 1 then
      unit.type = "Mudcrawler"
      extra_attacks = {}
      extra_effects = {}
      extra_effects_before_extra_attacks = {}
      default_melee_effects = {}
    else
      local best_melee  = 0
      local best_ranged = 0
      local consider_attack = function(attack)
        attack = EoHS.deep_copy(attack)
        for i,effect_pair in ipairs(extra_effects) do
          local effect = effect_pair[2]
          if (effect.apply_to == "attack") and EoHS.game_action_simulations.attack_matches_filter(attack, effect) then
            attack.damage = attack.damage + (effect.increase_damage or 0)
            attack.number = attack.number + (effect.increase_attacks or 0)
          end
        end
        local power = attack.damage*attack.number
        if attack.range == "melee"  then best_melee  = math.max(best_melee , power) end
        if attack.range == "ranged" then best_ranged = math.max(best_ranged, power) end
      end
      for i,attack in ipairs(EoHS.get_subtags(EoHS.unit_type_considering_variations(unit),"attack")) do consider_attack(attack) end
      for i,attack in ipairs(extra_attacks) do consider_attack(attack) end
      
      unit.type = "Giant Mudcrawler"
      if unit.level > 4 then
        new_name_override = _"Titanic Mudcrawler"
      else new_name_override = ({nil, _"Enormous Mudcrawler", _"Gargantuan Mudcrawler", _"Colossal Mudcrawler", _"Titanic Mudcrawler"})[unit.level] end
      extra_attacks = {}
      extra_effects = {}
      extra_effects_before_extra_attacks = {}
      default_melee_effects = {}
      
      local bonus = math.floor(math.abs(best_ranged - best_melee)/3)
      -- Try to keep things equal power, given that a bonus to your weaker attack is generally less good than a penalty to your primary attack.
      if best_ranged < best_melee then
           best_ranged = best_ranged + bonus
           best_melee  = best_melee  - (bonus/2)
      else best_melee  = best_melee  + bonus
           best_ranged = best_ranged - (bonus/2) end
      -- Favor ranged, because mudcrawlers do
      best_melee  = best_melee  - 2
      best_ranged = best_ranged + 2
      local swings_bonus = ((best_ranged + best_melee) > 45) and 1 or 0
      make_effect("attack", { range = "melee" , increase_damage = math.floor(0.5 + best_melee /(2+swings_bonus))-7, increase_attacks = swings_bonus })
      make_effect("attack", { range = "ranged", increase_damage = math.floor(0.5 + best_ranged/(3+swings_bonus))-5, increase_attacks = swings_bonus })
      if unit.level > 1 then
        local size = 72 + (unit.level-1)*14
        local crop =      (unit.level-1)*5
        make_effect("image_mod", { add = "~SCALE("..size..","..size..")~CROP(0,"..crop..","..size..","..(size-crop)..")" })
      end
    end
    make_effect("movement", { set = math.floor(movement / 2) })
    local new_type_cfg = EoHS.unit_type_considering_variations(unit)
    unit.alignment = new_type_cfg.alignment
    EoHS.set_unit_race(unit, new_type_cfg.race)
    type_name_override = EoHS.substitute(_"$1| ($2|)", {new_name_override or new_type_cfg.name, type_name_override or original_type_cfg.name})
  end
  
  local needs_undead_trait = false
  if variables.undying then
    make_effect("new_ability", { { "abilities", { {"dummy",{
      name=_"undying",
      description=_"This unit is unkillable; if it is reduced to 0 HP, it returns with 1 HP at the end of its next turn, or the next time the hex is empty.",
    }} }}})
    -- Adding the type name change isn't strictly necessary, since we add a dummy ability anyway,
    -- but it adds to the spell's coolness, which is important,
    type_name_override = EoHS.substitute(_"Undying $1|", {type_name_override or original_type_cfg.name})
  end
  if variables.is_reanimated and (unit.race ~= "undead") then
    if not variables.undying then
      type_name_override = EoHS.substitute(_"Undead $1|", {type_name_override or original_type_cfg.name})
    end
    needs_undead_trait = true
    EoHS.set_unit_race(unit, "undead")
    unit.alignment = "chaotic"
    local example = EoHS.unit_type_generic_example_considering_variations(unit)
    local new_resistances = EoHS.deep_copy(EoHS.get_subtag(example, "resistance"))
    local new_movement_costs = EoHS.deep_copy(EoHS.get_subtag(example, "movement_costs"))
    local new_defenses = EoHS.deep_copy(EoHS.get_subtag(example, "defense"))
    for i,effect_pair in ipairs(extra_effects) do
      local effect = effect_pair[2]
      if effect.apply_to == "resistance" then
        for k,v in pairs(EoHS.get_subtag(effect, "resistance")) do
          new_resistances[k] = (effect.replace and 0 or new_resistances[k] or 100) + v
        end
      end
      if effect.apply_to == "defense" then
        for k,v in pairs(EoHS.get_subtag(effect, "defense")) do
          if effect.replace or new_defenses[k] then
            new_defenses[k] = (effect.replace and 0 or new_defenses[k]) + v
          end
        end
      end
      if effect.apply_to == "movement_costs" then
        for k,v in pairs(EoHS.get_subtag(effect, "movement_costs")) do
          if effect.replace or new_movement_costs[k] then
            new_movement_costs[k] = (effect.replace and 0 or new_movement_costs[k]) + v
          end
        end
      end
    end
    local movement = EoHS.get_unit_type(unit.type).movement
    for i,effect_pair in ipairs(extra_effects) do
      local effect = effect_pair[2]
      if effect.apply_to == "movement" then
        if effect.set then movement = effect.set end
        if effect.increase then movement = movement + effect.increase end
      end
    end
    
    if new_defenses      .fungus      and (new_defenses      .fungus      > 30) then new_defenses      .fungus      = math.max(new_defenses.fungus      - 10, 30) end
    if new_defenses      .frozen      and (new_defenses      .frozen      > 60) then new_defenses      .frozen      = math.max(new_defenses.frozen      - 10, 60) end
    if new_movement_costs.frozen      and (new_movement_costs.frozen      >  2) then new_movement_costs.frozen      =    new_movement_costs.frozen      -  1      end
    if new_movement_costs.swamp_water and (new_movement_costs.swamp_water >  2) then new_movement_costs.swamp_water =    new_movement_costs.swamp_water -  1      end
    if new_movement_costs.shallow_water and (new_movement_costs.shallow_water <= movement) and not new_movement_costs.deep_water then
      new_movement_costs.deep_water =  new_movement_costs.shallow_water + 1
      new_defenses      .deep_water = (new_defenses      .shallow_water or 80) + 10
      make_effect("new_ability", { { "abilities", EoHS.macros.ABILITY_SUBMERGE } })
    end
    
    -- These comments were copied verbatim from the old EoHS 1.1 line, except for obvious mistakes.
    -- In general: Go for Lich-type resistances. (Lich, Ancient Lich, Death Knight, and Chocobone have those resistances at the time of this writing, with the only difference being Lich having -40% arcane instead of -50%.)
    -- A human/elf/orc/goblin should gain exact Lich resistances.
    -- Usually don't increase extreme resistances/weaknesses, because the fantasy mechanism for them is usually unrelated and non-interacting with the reason undead have these weaknesses.

    -- All existing physical undead, except the bizarre Skeletal Dragon, have either -40% or -50% arcane resistance.
    -- Decide which based on whether the unit is weak to arcane already.
    -- But don't reduce its resistance if it's already huge for some reason.
    new_resistances.arcane = math.max(new_resistances.arcane, (new_resistances.arcane > 100) and 150 or 140)

    -- All skeleton(ish) undead have -20% fire resistance. Dragons have 0%, ghouls have 10%.
    -- Leave the high fire weakness alone.
    -- Everything else does pretty much what I want if I just reduce it by 20% (cap at -20%.) Not-quite-as-fire-resistant drakes seem to make sense.
    new_resistances.fire = math.max(new_resistances.fire, math.min(120, new_resistances.fire + 20))

    -- Liches have -10% impact resist. Skeletons (including the dragon) -20%, ghouls 0%.
    -- Leave the high impact weakness alone.
    -- Units with huge impact resistance are usually that way because of attributes that SHOULDN'T change on an undead (exo-skeleton for Giant Scorpions, non-structuralness for mudcrawlers)
    -- Everything else does pretty much what I want if I just reduce it by 10% (cap at -10%.)
    new_resistances.impact = (new_resistances.impact>=50) and math.max(new_resistances.impact, math.min(110, new_resistances.impact + 10)) or new_resistances.impact

    -- Liches (and ghouls) have 10% blade resist. Skeletons (including the dragon) 40%.
    -- Leave the high blade resistance alone.
    -- Everything else does pretty much what I want if I just increase it by 10% (cap at 40%.)
    new_resistances.blade = math.min(new_resistances.blade, math.max(60, new_resistances.blade - 10))

    -- Liches (and ghouls) have 30% pierce resist. Skeletons (including the dragon) 60%.
    -- Leave the high pierce resistance alone.
    -- Everything else does pretty much what I want if I just increase it by 30% (cap at 60%.)
    new_resistances.pierce = math.min(new_resistances.pierce, math.max(40, new_resistances.pierce - 30))

    -- All skeleton(ish) undead have 60% cold resistance; ghouls have 40%.
    -- Leave the high cold resistance alone.
    -- Everything else does pretty much what I want if I just increase it by 60% (cap at 60%.)
    -- 2.0 note: Changed cap to 70%, like the ghost.
    new_resistances.cold = math.min(new_resistances.cold, math.max(30, new_resistances.cold - 60))
    
    make_effect("resistance"    , { replace=true, {"resistance"    ,new_resistances   }})
    make_effect("defense"       , { replace=true, {"defense"       ,new_defenses      }})
    make_effect("movement_costs", { replace=true, {"movement_costs",new_movement_costs}})
    make_effect("image_mod"     , { add = "~CS(110,110,110)~CS(-130,-120,-110)" })
  end
  if variables.undying then
    make_effect("image_mod"     , { add = "~CS(90,70,70)" })
  end
  
  local type_hitpoints = EoHS.get_unit_type(unit.type).hitpoints
  if hitpoints ~= type_hitpoints then
    make_effect("hitpoints", { increase_total = hitpoints-type_hitpoints })
  end
  local type_experience = EoHS.get_unit_type(unit.type).experience
  if experience ~= type_experience then
    make_effect("max_experience", { increase = experience-type_experience })
  end
  if force_zoc ~= nil then
    make_effect("zoc", { value=force_zoc })
  end
  
  variables.type_name_override = type_name_override
  
  for i,attack in ipairs(extra_attacks) do attack.apply_to = "new_attack"; table.insert(extra_effects_before_extra_attacks, {"effect",attack}) end
  for i,effect in ipairs(extra_effects) do table.insert(extra_effects_before_extra_attacks, effect) end
  extra_effects,extra_attacks,extra_effects_before_extra_attacks = extra_effects_before_extra_attacks,nil,nil
  extra_effects.id = "EoHS_type_adjustment_advancement"
  
  local modifications = EoHS.force_subtag(unit, "modifications")
  EoHS.remove_subtags(modifications, "advance", "EoHS_type_adjustment_advancement")
  if extra_effects[1] then
    table.insert(modifications, 1, { "advance", extra_effects }) -- advance comes before trait or object - it's fitting for type modifications
  end
  
  EoHS.remove_subtags(modifications, "object", "EoHS_mount_object")
  if variables.is_mounted then
    -- an object at the beginning: unaffected by traits (good), always affected by scenario equipment (not good, but better than depending on order added)
    table.insert(modifications, 1, { "object", EoHS.get_mount_effects(unit) })
  end
  
  -- times="per level" effects don't respect our level= overrides. Circumvent this.
  for i,modification_tag in ipairs(modifications) do
    EoHS.remove_subtags(modification_tag[2], "effect", function(t) return t.EoHS_per_level_replacement end)
    for effect in helper.child_range(modification_tag[2], "effect") do
      if effect.times == "per level" then
        effect.EoHS_per_level_apply_to = effect.apply_to or effect.EoHS_per_level_apply_to
        effect.apply_to = nil
        local single_effect = EoHS.deep_copy(effect)
        single_effect.EoHS_per_level_apply_to = nil
        single_effect.apply_to = effect.EoHS_per_level_apply_to
        single_effect.EoHS_per_level_replacement = true
        single_effect.times = nil
        for l=1,unit.level do
          table.insert(modification_tag[2], {"effect",single_effect})
        end
      end
    end
  end
  
  EoHS.prepare_max_moves_change(unit)
  EoHS.prepare_max_hitpoints_change(unit)
  
  -- TODO can we overwrite less stuff, to increase compatibility?
  local rewritten_subtags = {attack=true,abilities=true,defense=true,resistance=true,movement_costs=true}
  EoHS.remove_subtags(unit,"*",function(val,tagname) return rewritten_subtags[tagname] end)
  unit.max_hitpoints = nil
  unit.max_experience = nil
  unit.max_moves = nil
  unit.zoc = nil
  EoHS.get_fake_subtag(variables, "unit_attribute_memory").type = unit.type
  
  -- Wesnoth will automatically re-add these if appropriate
  EoHS.set_subtag_attribute(unit, "status.not_living")
  EoHS.remove_subtags(modifications, "trait", "undead")
  EoHS.remove_subtags(modifications, "trait", "elemental")
  EoHS.remove_subtags(modifications, "trait", "mechanical")
  -- Except for reanimated units, becuase they're not a unit type that specifies it
  if needs_undead_trait then
    table.insert(modifications, EoHS.macros.TRAIT_UNDEAD[1])
  end
  
  EoHS.shallow_overwrite(unit, EoHS.create_wunit(unit).__cfg)
  EoHS.finish_max_moves_change(unit)
  EoHS.finish_max_hitpoints_change(unit)
  
  if EoHS.get_subtag_attribute(unit, "status.not_living") then
    EoHS.set_subtag_attribute(unit, "status.poisoned")
  end
  
  -- Has to be done after the main regeneration above
  EoHS.update_conditional_abilities(unit)
  -- Hack, in case the unit's level was changed
  if EoHS.get_unit_variable(unit, "wizard_sword_turns") then EoHS.update_wizard_sword(unit) end
  
  EoHS.standardize_unit(unit)
  --EoHS.update_unit_graphics(unit) (standardize_unit calls it)
end

EoHS.abilities = {}
EoHS.abilities.regen_lesser = { {"regenerate",{
  value = 4,
  id = "EoHS_regen_lesser",
  name = _"regen +4",
  description = _"The unit will heal itself 4 HP per turn. If it is poisoned, it will remove the poison instead of healing.",
  affect_self = true,
  poison = "cured",
}} }
EoHS.abilities.invisible = { {"hides",{
  id = "EoHS_invisible",
  name= _ "invisible",
  female_name= _ "female^invisible",
  name_inactive= _ "invisible",
  female_name_inactive= _ "female^invisible",
  description = _"This unit can hide anywhere, and remain undetected by its enemies.\n\nEnemy units cannot see this unit, except if they have units next to it. Any enemy unit that first discovers this unit immediately loses all its remaining movement.",
  affect_self = true,
}} }
EoHS.abilities.deluminates = EoHS.deep_copy(EoHS.macros.ABILITY_ILLUMINATES)
EoHS.abilities.deluminates[1][2].value = -25
EoHS.abilities.deluminates[1][2].min_value = -25
EoHS.abilities.deluminates[1][2].max_value = nil
EoHS.abilities.deluminates[1][2].name= _ "deluminates"
EoHS.abilities.deluminates[1][2].female_name= _ "female^deluminates"
EoHS.abilities.deluminates[1][2].description= _ "This unit deluminates the surrounding area, making chaotic units fight better, and lawful units fight worse.\n\nAny units adjacent to this unit will fight as if it were night when it is dusk, and as if it were dusk when it is day."
EoHS.abilities.twilight = {EoHS.deep_copy(EoHS.macros.ABILITY_ILLUMINATES[1]),EoHS.deep_copy(EoHS.abilities.deluminates[1])}
EoHS.abilities.twilight[1][2].max_value = 0
table.insert(EoHS.abilities.twilight[1][2], { "filter_base_value", { less_than = 0 }})
EoHS.abilities.twilight[2][2].min_value = 0
table.insert(EoHS.abilities.twilight[2][2], { "filter_base_value", { greater_than = 0 }})
EoHS.abilities.twilight[1][2].name= _ "twilight"
EoHS.abilities.twilight[1][2].female_name= _ "female^twilight"
EoHS.abilities.twilight[1][2].description= _ "Any units adjacent to this unit will fight as if it were twilight at all times."
EoHS.abilities.twilight[2][2].name= nil
EoHS.abilities.twilight[2][2].female_name= nil
EoHS.abilities.twilight[2][2].description= nil
EoHS.abilities.protection = {
  { "resistance", {
    id = "EoHS_protection",
    cumulative = false,
    add = 30,
    max_value = 70,
    { "filter_base_value", { less_than = 70, }},
    affect_self = false,
    { "affect_adjacent", {
      adjacent = "n,ne,se,s,sw,nw",
    }},
           name = _"protection",
    female_name = _"female^protection",
    description = _"Your adjacent units get a 30% bonus to all resistances, to a maximum of 70%.",
  }}
}
EoHS.abilities.despair = {
  { "dummy", {
    id = "EoHS_despair",
           name = _"despair",
    female_name = _"female^despair",
    description = _"All enemy units within two hexes do 30% less damage.",
  }}
}
EoHS.despair_receiver_ability = { "leadership", {
  id = "EoHS_despair_receiver",
  cumulative = true,
  value = -30,
  affect_self = true,
  { "filter", {
    lua_function = "EoHS_despair_receiver_check"
    --[[ Much too slow:
    { "filter_location", {
      radius = 2,
      { "filter", { ability = "EoHS_despair", { "filter_side", { {"enemy_of",{side="$this_unit.side"}} }} }},
      { "filter_radius", { {"not",{ terrain="_*,X*" }}, {"not",{ terrain="*^_*,*^X*" }} }}, -- TODO name this filter
    }},]]
  }},
}}
EoHS.make_filter_func("EoHS_despair_receiver_check", function(wunit)
  for i,hex in ipairs(EoHS.find_reach(wunit.x, wunit.y, EoHS.passable_only(), 2)) do
    local wunit2 = wesnoth.get_unit(hex.x, hex.y)
    if wunit2 and (not wunit2.petrified) and wesnoth.is_enemy(wunit.side, wunit2.side) and wunit2.variables.EoHS_despair_ability then return true end
  end
  return false
end)
EoHS.abilities.light_control = {
  { "dummy", {
    id = "EoHS_light_control",
           name = _"light control",
    female_name = _"female^light control",
    description = _"All units within two hexes fight as if it was one time-of-day step in your favor (better for allies, worse for enemies). Technically uses 'leadership' abilities because the Wesnoth engine doesn't support an ability illuminating just one hex at a time",
  }}
}
EoHS.light_control_receiver_leadership_abilities_hack = {
  {"leadership",{
    id="EoHS_light_control_receiver",
    value=25,
    cumulative=true,
    affect_self=true,
    { "filter", {
      lua_function = "EoHS_light_control_receiver_ally_check"
    }},
  }},
  {"leadership",{
    id="EoHS_light_control_receiver",
    value=-25,
    cumulative=true,
    affect_self=true,
    { "filter", {
      lua_function = "EoHS_light_control_receiver_enemy_check"
    }},
  }},
}
EoHS.light_control_receiver_abilities = {
  neutral = {
    { "dummy", {
      id = "EoHS_light_control_receiver",
    }}
  },
  lawful = EoHS.light_control_receiver_leadership_abilities_hack,--[[{
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=25,
      max_value=25,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter", {
        lua_function = "EoHS_light_control_receiver_ally_check"
      }},
    }},
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=-25,
      max_value=-25,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter", {
        lua_function = "EoHS_light_control_receiver_enemy_check"
      }},
    }},
  },]]
  chaotic = EoHS.light_control_receiver_leadership_abilities_hack,--[[{
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=25,
      max_value=25,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter", {
        lua_function = "EoHS_light_control_receiver_enemy_check"
      }},
    }},
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=-25,
      max_value=-25,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter", {
        lua_function = "EoHS_light_control_receiver_ally_check"
      }},
    }},
  },]]
  liminal = EoHS.light_control_receiver_leadership_abilities_hack,--[[{
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=25,
      max_value=25,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter_base_value", { greater_than_equal_to = 0 }},
      { "filter", {
        lua_function = "EoHS_light_control_receiver_enemy_check"
      }},
    }},
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=-25,
      max_value=-25,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter_base_value", { less_than = 0 }},
      { "filter", {
        lua_function = "EoHS_light_control_receiver_enemy_check"
      }},
    }},
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=25,
      max_value=0,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter_base_value", { less_than = 0 }},
      { "filter", {
        lua_function = "EoHS_light_control_receiver_ally_check"
      }},
    }},
    {"illuminates",{
      id="EoHS_light_control_receiver",
      value=-25,
      max_value=0,
      cumulative=false,
      affect_self=true, affect_allies=false, affect_enemies=false,
      { "filter_base_value", { greater_than = 0 }},
      { "filter", {
        lua_function = "EoHS_light_control_receiver_ally_check"
      }},
    }},
  },]]
}
EoHS.make_filter_func("EoHS_light_control_receiver_enemy_check", function(wunit)
  local tod = wesnoth.get_time_of_day(nil, { wunit.x, wunit.y, true })
  local alignment = wunit.variables.EoHS_unit_attribute_memory_alignment
  if (alignment == "lawful" ) and ((tod.lawful_bonus < 0) or (wunit.variables.EoHS_unit_attribute_memory_is_fearless and (tod.lawful_bonus == 0))) then return false end
  if (alignment == "chaotic") and ((tod.lawful_bonus > 0) or (wunit.variables.EoHS_unit_attribute_memory_is_fearless and (tod.lawful_bonus == 0))) then return false end
  if (alignment == "liminal") and (tod.lawful_bonus ~= 0) then return false end
  for i,hex in ipairs(EoHS.find_reach(wunit.x, wunit.y, EoHS.passable_only(), 2)) do
    local wunit2 = wesnoth.get_unit(hex.x, hex.y)
    if wunit2 and (not wunit2.petrified) and wesnoth.is_enemy(wunit.side, wunit2.side) and wunit2.variables.EoHS_light_control_ability then return true end
  end
  return false
end)
EoHS.make_filter_func("EoHS_light_control_receiver_ally_check", function(wunit)
  local tod = wesnoth.get_time_of_day(nil, { wunit.x, wunit.y, true })
  local alignment = wunit.variables.EoHS_unit_attribute_memory_alignment
  if (alignment == "lawful" ) and ((tod.lawful_bonus > 0) or (wunit.variables.EoHS_unit_attribute_memory_is_fearless and (tod.lawful_bonus < 0))) then return false end
  if (alignment == "chaotic") and ((tod.lawful_bonus < 0) or (wunit.variables.EoHS_unit_attribute_memory_is_fearless and (tod.lawful_bonus > 0))) then return false end
  if (alignment == "liminal") and (tod.lawful_bonus == 0) then return false end
  for i,hex in ipairs(EoHS.find_reach(wunit.x, wunit.y, EoHS.passable_only(), 2)) do
    local wunit2 = wesnoth.get_unit(hex.x, hex.y)
    if wunit2 and (not wunit2.petrified) and (not wesnoth.is_enemy(wunit.side, wunit2.side)) and wunit2.variables.EoHS_light_control_ability then return true end
  end
  return false
end)
EoHS.abilities.leadership = function(level)
  local result = {}
  for level2 = level-1,0,-1 do
    table.insert(result, { "leadership", {
      id = "leadership",
      cumulative = false,
      value = 25*(level-level2),
      affect_self = false,
      { "affect_adjacent", {
        adjacent = "n,ne,se,s,sw,nw",
        { "filter", {
          level = level2,
        }},
      }},
             name = (level2==level-1) and EoHS.macros.ABILITY_LEADERSHIP_LEVEL_1[1][2].name or nil,
      female_name = (level2==level-1) and EoHS.macros.ABILITY_LEADERSHIP_LEVEL_1[1][2].female_name or nil,
      description = (level2==level-1) and EoHS.macros.ABILITY_LEADERSHIP_LEVEL_1[1][2].description or nil,
    }})
  end
  return result
end
EoHS.abilities.intimidate = function(level)
  local result = {}
  for level2 = level-1,0,-1 do
    table.insert(result, { "leadership", {
      id = "EoHS_intimidate",
      cumulative = false,
      value = -15*(level-level2),
      affect_self = false,
      affect_allies = false,
      affect_enemies = true,
      { "affect_adjacent", {
        adjacent = "n,ne,se,s,sw,nw",
        { "filter", {
          level = level2,
        }},
      }},
             name = (level2==level-1) and _"intimidate" or nil,
      female_name = (level2==level-1) and _"female^intimidate" or nil,
      description = (level2==level-1) and _"Adjacent enemy units of lower level will do 15% less damage times the level difference." or nil,
    }})
  end
  return result
end

-- TODO: Maybe this should be in a different file? It's not really about unit types.
local conditional_ability_data = {}
EoHS.make_conditional_ability = function(id, func)
  table.insert(conditional_ability_data, {id="EoHS_"..id,func=func})
  conditional_ability_data["EoHS_"..id] = true
end
EoHS.update_conditional_abilities = function(unit)
  local modifications = EoHS.get_subtag(unit, "modifications")
  local abilities_tag = EoHS.get_subtag(unit, "abilities")
  if abilities_tag then EoHS.remove_subtags(abilities_tag, "*", function(a) return conditional_ability_data[a.id] end) end
  EoHS.remove_subtags(modifications, "object", "EoHS_conditional_abilities_object")
  local abilities = {}
  for i,data in ipairs(conditional_ability_data) do
    local ability = data.func(unit)
    if ability then
      ability[2].id = data.id
      if not w111 then ability[2].description = EoHS.substitute("$1|:\n$2|", {ability[2].name,ability[2].description}) end
      table.insert(abilities, ability)
      if not abilities_tag then abilities_tag = EoHS.force_subtag(unit, "abilities") end
      table.insert(abilities_tag, ability)
    end
  end
  if abilities[1] then
    table.insert(modifications, {"object",{ id="EoHS_conditional_abilities_object", {"effect",{ apply_to = "new_ability", {"abilities",abilities}}}}})
  end
  
  -- We could do this. But to be polite to add-ons that add abilities crudely, we just mess with the existing abilities tag (see above).
  -- EoHS.remove_subtags(unit, "abilities")
end

-->>)}
