this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- actions.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

local w111 = wesnoth.compare_versions(wesnoth.game_config.version, ">=", "1.11.0")

EoHS.scroll_cost = 5

-- NOTE: works on wunits
-- TODO: reduce duplicate code between EoHS.unit_has_actions and EoHS.unit_actions
EoHS.unit_has_actions = function(unit)
  return EoHS.get_unit_variable(unit, "is_wizard") or EoHS.get_unit_variable(unit, "is_mounted") or EoHS.get_unit_variable(unit, "spiritform") or EoHS.get_unit_variable(unit, "touch_enchantment") or EoHS.get_unit_variable(unit, "ritual") or EoHS.get_unit_variable(unit, "has_scroll") or (EoHS.get_unit_variable(unit, "is_summon") and ((unit.type == "Fire Dragon") or (unit.type == "Yeti")))
end

EoHS.unit_has_action = function(unit, id)
  local actions = EoHS.unit_actions(unit)
  for i,id2 in ipairs(actions) do
    if id2 == id then return true end
  end
  return false
end

EoHS.unit_actions = function(unit)
  local result = {}
  if EoHS.get_unit_variable(unit, "ritual") then
    table.insert(result, "cancel_ritual")
  end
  if EoHS.get_unit_variable(unit, "spiritform") then
    table.insert(result, "end_spiritform")
  end
  if EoHS.get_unit_variable(unit, "is_mounted") then
    table.insert(result, "dismount")
  end
  if EoHS.get_unit_variable(unit, "touch_enchantment") == "dispelling_touch" then
    table.insert(result, "use_dispelling_touch")
  end
  if EoHS.get_unit_variable(unit, "touch_enchantment") == "reanimating_touch" then
    table.insert(result, "use_reanimating_touch")
  end
  if EoHS.get_unit_variable(unit, "touch_enchantment") == "mud_touch" then
    table.insert(result, "use_mud_touch")
  end
  if EoHS.get_unit_skill(unit, "mentor") then
    table.insert(result, "train_apprentice")
  end
  if EoHS.get_unit_variable(unit, "is_summon") then
    if unit.type == "Yeti" then
      table.insert(result, "earthworks")
    end
    if unit.type == "Fire Dragon" then
      table.insert(result, "dragon_breath")
    end
  end
  if EoHS.get_unit_variable(unit, "is_wizard") then
    if EoHS.get_resummonable_wunits(unit)[1] then table.insert(result, "resummon") end
    for i,spell_id in ipairs(EoHS.spells_known_from_skillset(EoHS.get_unit_skillset(unit))) do
      table.insert(result, spell_id)
      if spell_id == "summon_skeleton" then table.insert(result, "summon_skeleton_archer") end
      if spell_id == "summon_vampire_bat" then table.insert(result, "absorb_bats") end
      if spell_id == "vex_dragon_bones" then table.insert(result, "command_dragon_bones") end
    end
    --table.insert(result, "summon_wolf")
  end
  return result
end

local standard_action_aspects = {
  "ap","mana","range",
}
local g = function(contents) return { "grid", contents } end
local r = function(contents) return { "row", contents } end
local c = function(contents) return { "column", contents } end
local spacer = { "spacer", {}}

EoHS.action_list_entry_canvas = function(strings, image)
  local result = {}
  
  local texts = {
    { w = 200, },
    { w = 25, },
    { w = 45, },
    { w = 50, },
  }
  for i,string in ipairs(strings) do
    local text = texts[i]
    text.y = EoHS.macros.GUI__TEXT_VERTICALLY_CENTRED
    if texts[i-1] then
      text.x = texts[i-1].x + texts[i-1].w + 3
    else
      text.x = 6
    end
    text.h = "(text_height)"
    text.font_size = 14
    text.color = EoHS.dialog_color (EoHS.validity_color(string[1]))
    text.text = string[2]
  end
  for i,text in ipairs(texts) do
    text.x = "("..(text.x+text.w).."-text_width)"
    table.insert(result, {"text",text})
  end
  if image then
    table.insert(result, {"image",{
      x=0,y=0,w="(height)",h="(height)",
      name=image,
    }})
  end
  
  return result
end
local action_list_entry_size_str = "mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\nm"


EoHS.committed_parameters = function(parameters)
  if parameters.committed then return parameters end
  local action = EoHS.actions[parameters.action_id]
  local committed_parameters = EoHS.deep_copy(parameters)
  if action.commit then action.commit(committed_parameters) end
  committed_parameters.committed = true
  return committed_parameters
end

EoHS.action_dialog_stuff = function(dialog_context, parameters, list_entry_only, selected, switch_func_func)
  local action = EoHS.actions[parameters.action_id]
  local committed_parameters = EoHS.committed_parameters(parameters)
  
  local cost = EoHS.action_cost(committed_parameters)
  local range = EoHS.action_range(committed_parameters)
  local whole_action_valid = true
  local whole_action_scroll_valid = true
  local actor
  local action_image = action.image
  local action_name = action.name
  if parameters.actor_id then
    actor = EoHS.get_unit(parameters.actor_id)
    action_image = EoHS.mod_all_component_images(action_image, EoHS.TC_image_mod(actor.side, "magenta"))
  end
  if parameters.scroll_id then
    action_image = "attacks/blank-attack.png~O(0)~BLIT(icons/scroll_red.png~SCALE(40,40),0,0)~BLIT("..action_image.."~SCALE(40,40),20,20)"
    action_name = EoHS.substitute(_"Scroll of $1|", {action_name})
  end
  
  local standard_aspects = {}
  local extra_aspects = {}
  local all_action_stuff = EoHS.all_action_stuff ("independent", committed_parameters, {list_entry_only = list_entry_only, targeting_UI_unneeded = true})
  for index, thing in ipairs (all_action_stuff) do
    local s = thing[2]
    if thing [2].forbidden then
      whole_action_valid = false
      if not s.doesnt_affect_scribing then
        whole_action_scroll_valid = false
      end
    end
    if thing [2].scroll_forbidden then
      whole_action_scroll_valid = false
    end
    if thing[1] == "aspect" then
      if list_entry_only then
        if s.standard_aspect_index then standard_aspects[s.standard_aspect_index] = { not s.forbidden, s.value } end
      else
        local    type_widget = EoHS.label_with_validity(dialog_context, not s.forbidden, {label=(s.kind and s.kind..":" or "")}, "right")
        local   value_widget = EoHS.label_with_validity(dialog_context, not s.forbidden, {label=(s.value or "")}, "left")
        local details_widget = {"label",{wrap=true,characters_per_line=40,label=(s.details or "")}}
        local row = r{
          c{horizontal_grow=true, border="right", border_size=9, type_widget},
          c{horizontal_grow=true, border="right", border_size=9, value_widget},
          c{horizontal_grow=true, border="right", border_size=9, details_widget},
        }
        if s.standard_aspect_index then standard_aspects[s.standard_aspect_index] = row
        else table.insert(extra_aspects, row) end
      end
    end
  end
  
  if list_entry_only then
    local strings = {
      { whole_action_valid, action_name },
    }
    for i,id in ipairs(standard_action_aspects) do
      table.insert(strings, standard_aspects[id] or {true, ""})
    end
    --TODO damage entry
    
    return r{c{EoHS.fake_listbox_entry(dialog_context, action_list_entry_size_str, EoHS.action_list_entry_canvas(strings, action_image), selected, switch_func_func(parameters.action_id, parameters.scroll_id))}}, whole_action_valid, whole_action_scroll_valid
  else
    local aspect_rows = {}
    local text_rows = {}
    for i,id in ipairs(standard_action_aspects) do
      if standard_aspects[id] then
        table.insert(aspect_rows, standard_aspects[id])
      end
    end
    for i,aspect in ipairs(extra_aspects) do
      table.insert(aspect_rows, aspect)
    end
    for index, thing in ipairs (all_action_stuff) do
      if thing[1] == "text" then
        local color = thing [2].color
        if not color then
          color = EoHS.validity_color (not thing [2].forbidden)
        end
        table.insert (text_rows, r{c{ {"label",{wrap = true,characters_per_line=70, label = thing [2].text}, "left"} }})
      end
    end

    local rows = {}
    if action.extra_parameters_dialog_grid --[[and not parameters.scroll_id]] then
      local grid = action.extra_parameters_dialog_grid(dialog_context, parameters, committed_parameters)
      if grid then table.insert(rows, r{c{grid}}) end
    end
    if action.left_column_grid then
      table.insert(rows, r{c{ horizontal_grow=true, border="all",border_size=9, 
          g{r{
            c{ vertical_alignment="top",border="right",border_size=4, action.left_column_grid(dialog_context, committed_parameters, {action_image=action_image}) },
            c{ horizontal_grow=true,grow_factor=2, g{
              r{c{horizontal_alignment="left",{"label",{label=action_name,definition="title"}} }},
              r{c{horizontal_alignment="left",border="all",border_size=9, {"label",{wrap=true,characters_per_line=70,label=action.description}} }},
              r{c{g(aspect_rows)}},
              r{c{g(text_rows)}},
            }}
          }}
        }})
    else
      table.insert(rows, r{c{ horizontal_grow=true, border="all",border_size=9, 
          g{r{
            c{ vertical_alignment="top",border="right",border_size=4, {"image",{label=action_image}} },
            c{ horizontal_grow=true,grow_factor=2, g{
              r{c{horizontal_alignment="left",{"label",{label=action_name,definition="title"}} }},
              r{c{horizontal_alignment="left",border="all",border_size=9, {"label",{wrap=true,characters_per_line=70,label=action.description}} }},
            }}
          }}
        }})
      table.insert(rows, r{c{g(aspect_rows)}})
      table.insert(rows, r{c{g(text_rows)}})
    end
    return g(rows), whole_action_valid, whole_action_scroll_valid
  end
end

EoHS.actions_grid = function(dialog_context, parameters, subjects_grid, switch_func_func, cast_func, scribe_func)
  local actor = EoHS.get_unit(parameters.actor_id)
  local cost = {}
    
  local actions_you_have_grid
  if parameters.action_id then
    local standard_action_aspect_names = {
      ap=_"AP",mana=_"Mana",range=_"Range",
    }
    local key_strings = {{true,""}}
    for i,id in ipairs(standard_action_aspects) do
      table.insert(key_strings, { true, standard_action_aspect_names[id] })
    end
    --TODO damage entry
    local key_label = {"label",{id = dialog_context.make_unique_id(), label="mmmmmmmmm"}}
    dialog_context.preshow(function()
      wesnoth.set_dialog_canvas(1, EoHS.action_list_entry_canvas(key_strings), key_label[2].id)
    end)
    
    local main_action_parameters = parameters
    local rows = {}
    
    local literal_variables = EoHS.get_subtag(actor, "variables")
    for scroll in helper.child_range(literal_variables, "EoHS_scroll") do
      -- TODO reduce duplicate code ID YLsFO3WBeP
      local scroll_use_parameters = EoHS.deep_copy(scroll)
      scroll_use_parameters.actor_id = parameters.actor_id
      scroll_use_parameters.side = actor.side
      scroll_use_parameters.src_x = parameters.src_x
      scroll_use_parameters.src_y = parameters.src_y
      if scroll_use_parameters.scroll_id==parameters.scroll_id then main_action_parameters = scroll_use_parameters end
      local row = EoHS.action_dialog_stuff(dialog_context, scroll_use_parameters, true, scroll_use_parameters.scroll_id==parameters.scroll_id, switch_func_func)
      table.insert(rows, row)
    end
    
    local rolling_parameters = EoHS.deep_copy(parameters)
    rolling_parameters.scroll_id = nil
    local actions = EoHS.unit_actions(actor)
    --TODO: "all actions / known actions / usable actions"
    for i,id in ipairs(actions) do
      rolling_parameters.action_id = id
      local row = EoHS.action_dialog_stuff(dialog_context, rolling_parameters, true, (rolling_parameters.action_id==parameters.action_id) and not parameters.scroll_id, switch_func_func)
      table.insert(rows, row)
    end
    local list_grid
    if #rows > 7 then
      list_grid = g{r{c{ {"spacer",{height=190}} },c{vertical_grow=true, g{
        r{c{horizontal_grow=true, border="bottom", border_size=3, key_label}},
        r{ grow_factor=2, c{vertical_grow=true, {"scrollbar_panel",{ horizontal_scrollbar_mode="never", {"definition", rows } }} }}
      }} }}
    else
      list_grid = g{
        r{c{horizontal_grow=true, border="bottom", border_size=3, key_label}},
        r{ grow_factor=2, c{vertical_grow=true, g(rows) }}
      }
    end
    
    local main_action_committed_parameters = EoHS.committed_parameters(main_action_parameters)
  
    local action = EoHS.actions[main_action_parameters.action_id]
    cost = EoHS.action_cost(main_action_committed_parameters)
    local main_action_info_grid, current_action_valid, current_action_scroll_valid = EoHS.action_dialog_stuff(dialog_context, main_action_parameters)
    local cast_str
    local thumbnail_size_str = "mmmmmmm"
    local button_size_str
    local use = _"Use"
    if action.is_spell then use = _"Cast" end
    if action.is_ritual then use = _"Start casting" end
    cast_str = EoHS.substitute(_"$use| <b>$1|</b>", {use=use, action.name})
    button_size_str = cast_str
    button_size_str = string.gsub(button_size_str, "%b<>", "")
    -- lolhack: account for the fact that the button-sizing is based on a different size of text than what I write in afterwards
    button_size_str = button_size_str..string.rep("m",math.ceil(string.len(button_size_str)/7))
    -- Hack: obs and off-turn can't *cast* spells, but display the rest of the dialog accurately.
    if (actor.side ~= wesnoth.current.side) or (wesnoth.sides[actor.side].controller ~= "human") then
      current_action_valid = false
    end
    local canvas = { {"text",{
      x = "(width-text_width-12)",
      y = EoHS.macros.GUI__TEXT_VERTICALLY_CENTRED,
      w = "(text_width)",
      h = "(text_height)",
      font_size = 14,
      color = EoHS.dialog_color (EoHS.validity_color(current_action_valid)),
      text = cast_str,
      text_markup = true
    }} }
    button_size_str = "m\nm\n"..thumbnail_size_str..button_size_str.."\nm\nm"
    EoHS.add_hex_canvas(canvas, actor.x, actor.y, actor.side, {
      x = "10",
      y = "((height/2)-(image_height/2))",
      w = "(if(height<58,height,58))",
      h = "(if(height<58,height,58))",
    })
    local cast_button = dialog_context.button({label=button_size_str, id="cast_button"}, function()
      if action.no_targeting then
        cast_func()
      else
        local target_x, target_y = EoHS.choose_action_target (main_action_committed_parameters)
        if target_x then
          main_action_parameters.target_x = target_x
          main_action_parameters.target_y = target_y
          cast_func()
        end
      end
    end)
    dialog_context.preshow(function()
      EoHS.set_canvas_over_button(canvas, "cast_button")
    end)
    if not current_action_valid then
      dialog_context.preshow(function() wesnoth.set_dialog_active(false, "cast_button") end)
    end
    local main_action_rows = {
      r{ c{ cast_button, } },
    }
    if main_action_parameters.scroll_id or (action.is_spell and EoHS.get_unit_skill(actor, "scribe")) then
      local scribe_str
      local scribe_valid = true
      if main_action_parameters.scroll_id then
        local info = _"1 AP"
        if main_action_parameters.given_recently then
          info = _"can't - it was already given this turn"
          scribe_valid = false
        end
        scribe_str = EoHS.substitute(_"Give this scroll to another unit ($1|)", {info})
      else
        scribe_valid = current_action_scroll_valid
        scribe_str = EoHS.substitute(_"Create a scroll of <b>$1|</b> ($2| mana)", {action.name, (cost.mana or 0) + EoHS.scroll_cost})
      end
      if action.forbid_scrolls then
        scribe_valid = false
        scribe_str = EoHS.substitute(_"You can't make scrolls of <b>$1|</b>", {action.name})
      end
      local scribe_size_str = string.gsub(scribe_str, "%b<>", "")
      -- lolhack: account for the fact that the button-sizing is based on a different size of text than what I write in afterwards
      scribe_size_str = scribe_size_str..string.rep("m",math.ceil(string.len(button_size_str)/14))
      scribe_size_str = "m\nmmmmm"..scribe_size_str
      table.insert(main_action_rows, r{ c{ border="top", border_size=4, dialog_context.button({label=scribe_size_str, id="scribe_button"}, function()
        local options = {}
        local legal_targets_array = EoHS.find_reach (parameters.src_x, parameters.src_y, EoHS.known_passable_only (parameters.side), 1)
        EoHS.filter (legal_targets_array, function(target)
          return EoHS.get_unit (target.x, target.y) and true or false
        end)
        options.legal_targets = legal_targets_array
        
        options.actor = actor
        options.name = EoHS.substitute (_"Giving a scroll of $1|", {action.name})

        local target_x, target_y = EoHS.choose_target (options)
        if target_x then
          main_action_parameters.target_x = target_x
          main_action_parameters.target_y = target_y
          scribe_func()
        end
      end) }})
      local scribe_canvas = { {"text",{
        x = EoHS.macros.GUI__TEXT_HORIZONTALLY_CENTRED,
        y = EoHS.macros.GUI__TEXT_VERTICALLY_CENTRED,
        w = "(text_width)",
        h = "(text_height)",
        font_size = 12,
        color = EoHS.dialog_color (EoHS.validity_color(scribe_valid)),
        text = scribe_str,
        text_markup = true
      }},
      {"image",{
        x = 10,
        w = "(height)",
        h = "(height)",
        name = "icons/scroll_red.png"
      }} }
      dialog_context.preshow(function()
        EoHS.set_canvas_over_button(scribe_canvas, "scribe_button")
      end)
      if not scribe_valid then
        dialog_context.preshow(function() wesnoth.set_dialog_active(false, "scribe_button") end)
      end
    end
    table.insert(main_action_rows, r{ c{ border="top", border_size=4, main_action_info_grid }, })
    actions_you_have_grid = g{
      r{ c{ border="all", border_size=4, list_grid }, c{g(main_action_rows)} },
    }
  else
    actions_you_have_grid = g{r{c{ border="all", border_size=14, {"label",{label=_"You have no actions to use."}} }}}
  end
  
  local resource_rows = {}
  local make_resource_row = function(name, amount, spent)
    local validity = (spent and (amount < spent)) and "impossible" or "valid"
    local cols = {
      c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, validity, { definition = "default_large", label = name   }, "right") },
      c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, "valid" , { definition = "default_large", label = amount }, "right") },
    }
    if spent then
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, "undesirable", { definition = "default_large", label = " - "          }, "right") })
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, "undesirable", { definition = "default_large", label = spent          }, "right") })
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, validity,      { definition = "default_large", label = " = "          }, "right") })
      table.insert(cols, c{ horizontal_grow=true, EoHS.label_with_validity(dialog_context, validity,      { definition = "default_large", label = (amount-spent) }, "right") })
    else
      table.insert(cols, c{ {"spacer",{}} })
      table.insert(cols, c{ {"spacer",{}} })
      table.insert(cols, c{ {"spacer",{}} })
      table.insert(cols, c{ {"spacer",{}} })
    end
    table.insert(resource_rows, r(cols))
  end
  
  if EoHS.unit_mana_income(actor) then
    local mana = EoHS.get_unit_variable(actor, "mana")
    local can_spend_gold_on_spells = EoHS.get_wizard_setting(actor, "can_spend_gold_on_spells")
    make_resource_row(_"Mana: ", mana, (can_spend_gold_on_spells and cost.mana) and math.min(mana,cost.mana) or cost.mana)
    if can_spend_gold_on_spells or cost.gold then
      local gold = wesnoth.sides[actor.side].gold
      make_resource_row(_"Gold: ", gold, (cost.mana or cost.gold) and ((cost.gold or 0) + math.max(0, (cost.mana or 0) - mana)))
      if can_spend_gold_on_spells then
        make_resource_row(_"Total: ", mana+gold, (cost.mana or cost.gold) and ((cost.mana or 0) + (cost.gold or 0)))
      end
    end
  end
  make_resource_row(_"AP: ", EoHS.get_unit_action_points(actor), cost.action_points)
  
  return g{
    r{c{horizontal_grow=true,
      g{r{
        c{ border="all", border_size=12, g(resource_rows) },
        c{ horizontal_grow=true, grow_factor=2, vertical_alignment="top", subjects_grid }
      }}
    }},
    r{c{actions_you_have_grid}},
  }
end
  
EoHS.sides_who_can_see_action = function(parameters, stuff)
  local sides_who_can_see_action = {}
  for side in ipairs(wesnoth.sides) do
    if parameters.side and not wesnoth.is_enemy(side, parameters.side) then sides_who_can_see_action[side] = true end
    if parameters.src_x and not sides_who_can_see_action[side] then
      if EoHS.hex_is_unfogged(parameters.src_x, parameters.src_y, side) then
        sides_who_can_see_action[side] = true
      end
    end
    if stuff and not sides_who_can_see_action[side] then
      for i,thing in ipairs(stuff) do
        -- By default, assume that any positional stuff represents an effect that can be seen by other players. This isn't quite correct, because some stuffs are positioned based on what's visible to the casting side. However, I believe all current such things are conservative â€“ they fall fully within the footprint of what can be seen anyway.
        local hex = thing [2]
        if hex.x and not hex.hidden_from_enemies then
          if EoHS.hex_is_unfogged(hex.x, hex.y, side) then
            sides_who_can_see_action[side] = true
            break
          end
        end
      end
    end
  end
  return sides_who_can_see_action
end

EoHS.for_those_who_see = function(parameters, sides_who_can_see_action, func)
  -- disunified: each client displays its own cast message
  local local_client_can_see = false
  local local_client_controls_any_side = false
  EoHS.disunified(function()
    for side in ipairs(wesnoth.sides) do
      if (wesnoth.sides[side].controller == "human") or (wesnoth.sides[side].controller == "human_ai") then
        local_client_controls_any_side = true
        if sides_who_can_see_action[side] then local_client_can_see = true end
      end
      if local_client_can_see then break end
    end
    if not local_client_controls_any_side then local_client_can_see = true end -- observers get to see everything
    if local_client_can_see then
      local seen_target_unit = EoHS.get_unit(parameters.target_x, parameters.target_y)
      if local_client_controls_any_side and seen_target_unit then
        seen_target_unit = nil
        for side in ipairs(wesnoth.sides) do
          if (wesnoth.sides[side].controller == "human") or (wesnoth.sides[side].controller == "human_ai") then
            seen_target_unit = EoHS.get_seen_unit(parameters.target_x, parameters.target_y, side)
          end
          if seen_target_unit then break end
        end
      end
      func(seen_target_unit)
    end
  end)
end

EoHS.unfog_for_those_who_see = function(sides_who_can_see_action, x, y)
  -- Make the caster visible for sides who can see
  if w111 then
    local sides_list = {}
    for side,can in ipairs(sides_who_can_see_action) do if can then table.insert(sides_list,side) end end
    wesnoth.fire("lift_fog", {
      x = x, y = y,
      { "filter_side", { side=table.concat(sides_list,",") } },
    })
  else
    -- In 1.10, we can't clear just a single hex.
    -- Instead, clear as little as possible: that hex plus every adjacent hex.
    -- Nixed because it caused unavoidable graphical glitches in *normal* situations (unit ellipse cycles color oddly),
    -- while the alternative is to cause glitches in *strange* situations (e.g. getting fireballed from fog)
    --[[
    local old_max_moves = actor.max_moves
    actor.max_moves = 0
    EoHS.put_unit(actor, {immediate=true})
    local wunit = wesnoth.get_unit(actor.x,actor.y)
    for side,can in ipairs(sides_who_can_see_action) do
      if can and (side ~= actor.side) then
        wunit.side = side
        wesnoth.fire("redraw",{clear_shroud=true,side=side})
      end
    end
    actor.max_moves = old_max_moves
    EoHS.put_unit(actor, {immediate=true})]]
  end
end

EoHS.do_action = function(parameters)
  local action = EoHS.actions[parameters.action_id]
  local stuff = EoHS.all_action_stuff (parameters)
  local cost
  
  if parameters.actor_id then
  local actor = EoHS.get_unit(parameters.actor_id)
  if parameters.scroll_id then
    -- TODO reduce duplicate code ID YLsFO3WBeP
    local old_params = parameters
    parameters = EoHS.remove_scroll(actor, parameters.scroll_id)
    EoHS.put_unit(actor)
    parameters.actor_id = old_params.actor_id
    parameters.side = actor.side
    parameters.src_x = old_params.src_x
    parameters.src_y = old_params.src_y
    parameters.target_x = old_params.target_x
    parameters.target_y = old_params.target_y
  end
  cost = EoHS.action_cost(parameters)
  for i,thing in ipairs(stuff) do
    local hex = thing [2]
    if hex.require_no_invisible_enemy then
      local unit = EoHS.get_unit(hex.x,hex.y)
      if unit and wesnoth.is_enemy(unit.side, actor.side) then
        EoHS.do_only_on_client_controlling_side(actor.side, function()
          EoHS.message(EoHS.substitute(_"Your action ($3|) was disrupted by an invisible unit at ($1|,$2|). Try again.", {hex.x,hex.y,action.name}))
        end)
        return
      end
    end
  end
  EoHS.pay_action_cost(parameters, cost)
  
  -- Wizards cannot be invisible while casting!
  EoHS.set_unit_status_immediate(actor, "uncovered", true)
  end
  
  local sides_who_can_see_action = EoHS.sides_who_can_see_action(parameters, stuff)
    
  -- disunified: each client displays its own cast message
  local local_client_can_see = false
  EoHS.for_those_who_see(parameters, sides_who_can_see_action, function(seen_target_unit)
    local_client_can_see = true
    local use_message, extra_values = action.use_message
    if type(use_message) == "function" then use_message, extra_values = use_message(parameters) end
    if not use_message then
      local action_gets_used
      if parameters.actor_id then
        action_gets_used = _"$actor_name| ($actor.x|,$actor.y|) $uses| $action.name|"
      else
        action_gets_used = _"$action.name| happens spontaneously"
      end
      if action.target_type then
        if seen_target_unit then
              use_message = action_gets_used.._" at $target_name| ($target.x|,$target.y|)."
        else use_message = action_gets_used.._" at ($target_x|,$target_y|)." end
      elseif parameters.src_x and not parameters.actor_id then
        use_message = action_gets_used.._" at ($src_x|,$src_y|)."
      else
        use_message =action_gets_used.._"."
      end
    end
    EoHS.action_message(parameters, use_message, extra_values)
  end)
  
  if parameters.src_x then EoHS.unfog_for_those_who_see(sides_who_can_see_action, parameters.src_x, parameters.src_y) end
  
  local extras = {
    do_on_clients_who_see = function(func) EoHS.disunified(function() if local_client_can_see then func() end end) end,
    cost_paid = helper.get_child(parameters, "cost_paid") or cost,
  }
  
  EoHS.disunified(function() if local_client_can_see then EoHS.lock_view()   end end)
  EoHS.during_action = true
  EoHS.actions[parameters.action_id].happen(parameters, extras)
  EoHS.during_action = nil -- TODO decide whether actions can be nested
  EoHS.disunified(function() if local_client_can_see then EoHS.unlock_view() end end)
end

EoHS.update_scroll_overlays = function(unit)
  local variables = EoHS.force_unit_variables(unit)
  local literal_variables = EoHS.get_subtag(unit, "variables")
  --if variables.scroll_overlays then
  --  unit.overlays = string.gsub(unit.overlays, EoHS.lua_pattern_escape(variables.scroll_overlays), "", 1)
  --end
  local any
  local scroll_overlays = "misc/blank-hex.png~BLIT(icons/scroll_red.png~SCALE(12,12),46,2)"
  local offsy = 14
  for scroll in helper.child_range(literal_variables, "EoHS_scroll") do
    any = true
    local action = EoHS.actions[scroll.action_id]
    scroll_overlays = EoHS.image_aggregates_combined(scroll_overlays, {image_modded=action.image.."~SCALE(12,12)", offset={x=21,y=offsy-36}})
    offsy = 66-math.floor(((66-offsy)*5)/6)
  end
  variables.scroll_overlays = any and EoHS.collapse_image_aggregate("image_modded", scroll_overlays) or nil
  --if any then unit.overlays = unit.overlays..","..variables.scroll_overlays end
  EoHS.update_unit_overlays(unit)
end

EoHS.soon(function()
  EoHS.at_turn_refresh("has_scroll", function(units)
    for i,unit in ipairs(units.with_variable.has_scroll or {}) do
      local literal_variables = EoHS.get_subtag(unit, "variables")
      for scroll in helper.child_range(literal_variables, "EoHS_scroll") do
        scroll.given_recently = false
      end
      EoHS.put_unit(unit)
    end
  end)
end)

EoHS.add_scroll = function(unit, parameters)
  local variables = EoHS.force_unit_variables(unit)
  local literal_variables = EoHS.get_subtag(unit, "variables")
  table.insert(literal_variables, {"EoHS_scroll",parameters})
  variables.has_scroll = true
  variables["has_scroll_"..parameters.scroll_id] = true
  EoHS.update_scroll_overlays(unit)
end

EoHS.remove_scroll = function(unit, scroll_id)
  local result
  local variables = EoHS.force_unit_variables(unit)
  local literal_variables = EoHS.get_subtag(unit, "variables")
  local num_left = 0
  local removed = EoHS.remove_subtags(literal_variables, "EoHS_scroll", function(parameters)
    if parameters.scroll_id == scroll_id then
      result = parameters
      return true
    else
      num_left = num_left + 1
    end
  end)
  EoHS.assert(removed == 1, "EoHS.remove_scroll related bug...?")
  if num_left == 0 then variables.has_scroll = nil end
  variables["has_scroll_"..scroll_id] = nil
  EoHS.update_scroll_overlays(unit)
  return result
end

EoHS.make_new_scroll_id = function()
  EoHS.assert(EoHS.context.unison, "EoHS.make_new_unit_id used in an disunified context")
  local id = EoHS.get_variable("next_scroll_id")
  EoHS.set_variable("next_scroll_id", id + 1)
  return id
end

EoHS.scribe_scroll = function(parameters)
  -- hack
  if parameters.scroll_id then return EoHS.give_scroll(parameters) end
  
  local actor = EoHS.get_unit(parameters.actor_id)
  local target = EoHS.get_unit(parameters.target_x, parameters.target_y)
  local cost = EoHS.action_cost(parameters)
  EoHS.pay_action_cost(parameters, cost)
  EoHS.pay_action_cost(parameters, {mana = EoHS.scroll_cost})
  
  -- Wizards cannot be invisible while casting!
  EoHS.set_unit_status_immediate(actor, "uncovered", true)
  
  local sides_who_can_see_action = EoHS.sides_who_can_see_action(parameters, {x=parameters.target_x,y=parameters.target_y})
  
  EoHS.for_those_who_see(parameters, sides_who_can_see_action, function(seen_target_unit)
    if seen_target_unit then
      EoHS.action_message(parameters, _"$actor_name| ($actor.x|,$actor.y|) creates a scroll of $action.name| for $target_name| ($target.x|,$target.y|).")
    else
      EoHS.action_message(parameters, _"$actor_name| ($actor.x|,$actor.y|) creates a scroll of $action.name| for a unit you can't see ($target.x|,$target.y|).")
    end
  end)
  
  EoHS.unfog_for_those_who_see(sides_who_can_see_action, actor.x, actor.y)
  
  parameters.scroll_id = EoHS.make_new_scroll_id()
  parameters.scroll_AP_cost = cost.action_points
  table.insert(parameters, {"cost_paid", cost})
  parameters.given_recently = (actor ~= target)
  EoHS.add_scroll(target, parameters)
  EoHS.put_unit(target)
end

EoHS.give_scroll = function(parameters)
  local actor = EoHS.get_unit(parameters.actor_id)
  local target = EoHS.get_unit(parameters.target_x, parameters.target_y)
  local stored_parameters = EoHS.remove_scroll(actor, parameters.scroll_id)
  
  EoHS.pay_action_cost(parameters, {action_points=1})
  stored_parameters.given_recently = true
  EoHS.add_scroll(target, stored_parameters)
  EoHS.put_unit(actor)
  EoHS.put_unit(target)
end

EoHS.pay_action_cost = function(parameters, cost)
  if cost.gold then
    local actor = EoHS.get_unit(parameters.actor_id)
    wesnoth.sides[actor.side].gold = wesnoth.sides[actor.side].gold - cost.gold
  end
  if cost.mana then
    local mana_paid, gold_paid = EoHS.deduct_mana_andor_gold(parameters.actor_id, cost.mana)
    cost.mana = mana_paid
    cost.gold = (cost.gold or 0) + gold_paid
  end
  if cost.action_points then
    local actor = EoHS.get_unit(parameters.actor_id)
    EoHS.set_unit_action_points_immediate(actor, EoHS.get_unit_action_points(actor) - cost.action_points)
    -- and if it uses action points then it's tiring
    EoHS.set_unit_attribute_immediate(actor, "resting", false)
  end
  if cost.once_per_turn then
    local actor = EoHS.get_unit(parameters.actor_id)
    EoHS.set_unit_variable_immediate (actor, "used_"..parameters.action_id, true)
  end
end

EoHS.attack_AP_cost = function(unit)
  if unit.max_attacks == 0 then return 1000 end
  if unit.max_attacks == 1 then return 6 end
  if unit.max_attacks == 2 then return 4 end
  return 3
  --return EoHS.get_unit_variable(unit, "is_lich") and 4 or 6
end

EoHS.unit_base_action_points = function(unit)
  if EoHS.is_building(unit) then return 0 end
  local attack = EoHS.attack_AP_cost(unit)
  local min = attack * unit.max_attacks
  local max = attack * unit.max_attacks + (attack-1)
  if max < 11 then return max end
  if min > 11 then return min end
  return 11
end

EoHS.get_unit_action_points = function(unit)
  return (EoHS.attack_AP_cost(unit)*unit.attacks_left) + (EoHS.get_unit_variable(unit, "extra_action_points") or 5)
end

-- TODO: "immediate" doesn't work right with the overlays, what to do
EoHS.set_unit_action_points_immediate = function(unit, amount)
  local attack_AP_cost = EoHS.attack_AP_cost(unit)
  EoHS.set_unit_attribute_immediate(unit, "attacks_left", math.floor(amount / attack_AP_cost))
  EoHS.set_unit_variable_immediate(unit, "extra_action_points", amount % attack_AP_cost)
  EoHS.update_unit_overlays_immediate(unit)
end

EoHS.deduct_mana_andor_gold = function(unit_id, amount)
  local unit = EoHS.get_unit(unit_id)
  local mana = EoHS.get_unit_variable(unit, "mana")
  if mana <= 0 then
    wesnoth.sides[unit.side].gold = wesnoth.sides[unit.side].gold - amount
    return 0, amount
  elseif mana < amount then
    EoHS.set_unit_variable_immediate(unit, "mana", 0)
    wesnoth.sides[unit.side].gold = wesnoth.sides[unit.side].gold + mana - amount
    return mana, amount - mana
  else
    EoHS.set_unit_variable_immediate(unit, "mana", mana - amount)
    return amount, 0
  end
end

EoHS.unit_mana_income = function(unit)
  if EoHS.get_unit_variable(unit, "is_wizard") then
    return EoHS.get_wizard_setting(unit, "mana_income_at_level_0") + 
           EoHS.get_wizard_setting(unit, "mana_income_per_level")*unit.level +
           (EoHS.get_unit_variable(unit, "soul_bind_mana_income") or 0)
  end
  if EoHS.get_unit_variable(unit, "is_summon") then
    if unit.type == "Fire Dragon" then return 2*unit.level end
  end
end
EoHS.unit_mana_cap = function(unit)
  if EoHS.get_unit_variable(unit, "is_wizard") then
    local setting = EoHS.get_wizard_setting(unit, "mana_capacity_per_level")
    if setting == "infinite" then return nil end
    return setting*unit.level
  end
end
EoHS.earn_mana = function(unit, amount)
  local mcap = EoHS.unit_mana_cap(unit)
  local old_mana = EoHS.get_unit_variable(unit, "mana") or 0
  if (not mcap) or (old_mana < mcap) then
    local new_mana = old_mana + amount
    if mcap and (new_mana > mcap) then
      new_mana = mcap
    end
    EoHS.set_unit_variable_immediate(unit, "mana", new_mana)
  end
end
EoHS.earn_mana_income = function(unit)
  if wesnoth.current.turn > 1 then -- parallel to built-in rule about gold income
    local mincome = EoHS.unit_mana_income(unit)
    if mincome and (mincome > 0) then
      EoHS.earn_mana(unit, mincome)
    end
  end
end

EoHS.action_cost = function(parameters)
  local action = EoHS.actions[parameters.action_id]
  local cost
  if type(action.base_cost) == "function" then
    cost = action.base_cost(parameters)
  else
    cost = EoHS.deep_copy(action.base_cost)
  end
  cost = cost or {}
  
  local actor = EoHS.get_unit(parameters.actor_id)
  --local forceful = parameters.forceful and 120 or 100
  if actor and action.is_summon then
    if cost.action_points and EoHS.get_unit_skill(actor, "summoner") and not action.is_ritual then
      cost.action_points = cost.action_points - 2
    end
    if cost.mana then
      local multiplier = EoHS.get_wizard_setting(actor, "summon_cost_multiplier") or 100
      cost.mana = math.floor((cost.mana * multiplier--[[ * forceful]] + 50) / 100)
    end
  end
  --[[if cost.mana and action.is_attack_spell then
    cost.mana = math.floor((cost.mana*forceful + 50)/100)
  end]]
  if cost.mana and action.is_spell and EoHS.get_unit_skill(actor, "efficiency") then
    cost.mana = math.floor((cost.mana*8+5)/10)
  end
  if cost.action_points and EoHS.get_unit_skill(actor, "enchanter") and action.is_enchantment and not action.is_ritual then
    cost.action_points = cost.action_points - 2
  end
  
  if parameters.scroll_id then
    cost.action_points = parameters.scroll_AP_cost
    cost.mana = nil
    cost.gold = nil
  end
  
  return cost
end

EoHS.apply_farseer = function(number, parameters)
  return parameters.farseer and (number*2) or number
end

EoHS.action_range = function(parameters)
  local action = EoHS.actions[parameters.action_id]
  local actor = EoHS.get_unit(parameters.actor_id)
  local range
  if type(action.base_range) == "function" then
    range = action.base_range(parameters)
  else
    range = action.base_range
  end
  if not range then return nil end
  
  if action.is_spell then
    range = EoHS.apply_farseer(range, parameters)
  end
  return range
end

EoHS.action_message = function(parameters, string, extra_values)
  local values = {}
  for k,v in pairs(parameters) do if type(k) ~= "number" then values[k] = v end end
  if extra_values then for k,v in pairs(extra_values) do values[k] = v end end
  local action = EoHS.actions[parameters.action_id]
  values.action = {}
  for k,v in pairs(action) do
    if (type(k) == "string") and (type(v) ~= "function") and (type(v) ~= "table") then values.action[k] = v end
  end
  if parameters.actor_id then
    values.actor = EoHS.get_unit(parameters.actor_id)
    if values.actor then values.actor_name = EoHS.unit_appellation(values.actor) end
  end
  if parameters.target_x then
    values.target = EoHS.get_unit(parameters.target_x, parameters.target_y)
    if values.target then values.target_name = EoHS.unit_appellation(values.target) end
  end
  values.uses = _"uses"
  if action.is_spell then values.uses = _"casts" end
  if action.is_ritual then values.uses = _"starts casting" end
  EoHS.message(EoHS.substitute(string, values))
end

EoHS.begin_casting = function(actor_id, target_x, target_y)
  local actor = EoHS.get_unit(actor_id)
  if actor then
    wesnoth.scroll_to_tile(actor.x, actor.y, true)

    if target_x then
      EoHS.face_towards(actor, target_x, target_y)
    end

    EoHS.set_unit_attribute_immediate(actor, "facing", actor.facing)
    EoHS.redraw()
    EoHS.set_unit_variable_immediate(actor, "is_casting_a_spell", true)
    EoHS.animate_unit({
      flag = "EoHS_start_casting",
      with_bars = true,
      { "filter", { x=actor.x, y=actor.y, }},
    }, {dont_redraw_first=true})
  end
  if target_x then
    wesnoth.scroll_to_tile(target_x, target_y, true)
  end
end

EoHS.finish_casting = function(actor_id)
  EoHS.redraw()
  local actor = EoHS.get_unit(actor_id)
  -- In rare cases, the spell might have killed the caster, so only proceed if they can be found:
  if actor then
    EoHS.set_unit_variable_immediate(actor, "is_casting_a_spell")
    EoHS.animate_unit({
      flag = "EoHS_stop_casting",
      with_bars = true,
      { "filter", { x=actor.x, y=actor.y, }},
    }, {dont_redraw_first=true})
  end
end

EoHS.actions = {}
EoHS.make_action = function(id, action)
  if (type(action.image) ~= "string") or not (string.match(action.image, "attacks/") or string.match(action.image, "icons/")) then
    action.image = EoHS.collapse_image_aggregate("image_modded", EoHS.image_aggregates_combined(
      "attacks/blank-attack.png",
      EoHS.image_aggregate_cropped(action.image, {size={x=50,y=50},offset={x=0,y=0}})
    ))
  end
  action.id = id
  EoHS.actions[id] = action
end

EoHS.make_spell = function(id, action)
  action.is_spell = true
  EoHS.make_action(id, action)
end


-->>)}
